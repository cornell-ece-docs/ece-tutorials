{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Cornell ECE This website serves as a launchpad for Cornell's ECE courses, teaching the technical skills you need to know to use the ecelinux servers. In addition, the tutorials on this site cover common software development tools such as git and VS Code . Tutorials Please take a look at the beginner tutorials as instructed by your course staff. ECELinux Access Linux Command Line Basics Using Git Guides C/C++ Style Guide","title":"Home"},{"location":"#welcome-to-cornell-ece","text":"This website serves as a launchpad for Cornell's ECE courses, teaching the technical skills you need to know to use the ecelinux servers. In addition, the tutorials on this site cover common software development tools such as git and VS Code .","title":"Welcome to Cornell ECE"},{"location":"#tutorials","text":"Please take a look at the beginner tutorials as instructed by your course staff. ECELinux Access Linux Command Line Basics Using Git","title":"Tutorials"},{"location":"#guides","text":"C/C++ Style Guide","title":"Guides"},{"location":"doc0-coding-style/","text":"ECE C/C++ Coding Conventions Any significant programming project will usually require developers to follow a standardized set of coding conventions. These conventions might be set by a company, the leaders of an open-source project, or simply through historical precedent. Standardized coding conventions enable code written by multiple developers to be consistent and improves readability, maintainability, and extensibility. We have developed a simple set of coding conventions for your ECE coursework that we would like you to use in all programming assignments. Keep in mind that these are just guidelines, and there may be situations where it is appropriate to defy a convention. Note that some of these conventions have been adapted from the Google C++ Style Guide . In general, anything not covered by the guidelines in this document should assume the Google style guide. 1. Directories and Files This section discusses how the file tree should be organized for your project. 1.1. Directories All header, inline, data, and source files should be in a single src directory. All tests should be a in a single tests directory. Anything other than ad-hoc testing should always be done in a separate build directory. 1.2. File Names Files should be named in all lowercase and should use a dash ( - ) to separate words. C source files should use the .c filename extension, and C++ source files should use the .cc filename extension. Header files should use the .h filename extension, and inline files should use the .inl filename extension. Data files that contain C/C++ code and are meant to be included using the C preprocessor should use the .dat filename extension. All test programs should end in -test.c . All evaluation programs should end in -eval.c . 1.3. Header and Inline Files All header files should be self-contained. A header should include all other headers it needs. The definitions for template and inline functions should be placed in a separate .inl file and included at the end of the header. Every header should use include guards where the name of the include guard preprocessor macro is derived directly from the filename. For example, a header file named foo-bar.h would use the following include guards: #ifndef FOO_BAR_H #define FOO_BAR_H #endif // FOO_BAR_H 2. Formatting This section discusses general formatting that is common across all kinds of files. 2.1. Line Length Lines in all files should in general be less than 80 characters. Using less than 74 characters is ideal since this is a natural width that enables reasonable font sizes to be used when using side-by-side code development with two listings on modern laptops and side-by-side code development with three to four listings on 24\" to 27\" monitors. Lines longer than 80 characters should be avoided unless there is a compelling reason to use longer lines to increase code quality. 2.2. Indentation Absolutely no tabs are allowed. Only spaces are allowed for the purposes of indentation. The standard number of spaces per level of indentation is two. Here is an example: int gcd( int x, int y ) { while ( y != 0 ) { if ( x < y ) { int temp = x; y = temp; x = y; } else { x = x - y; } } return x; } 2.3. Vertical Whitespace Vertical whitspace can and should be used to separate conceptually distinct portions of your code. A blank line within a block of code serves like a paragraph break in prose: visually separating two thoughts. Vertical whitespace should be limited to a single blank line. Do not use two or more blank lines in a row. Do not include a blank line at the beginning and end of the function body in a function definition. So this is incorrect: int foo() { stmt1; return 0; } This is correct: int foo() { stmt1; return 0; } 2.4. Horizontal Whitespace Absolutely no tabs are allowed. Only spaces are allowed for the purposes of indentation. The standard number of spaces per level of indentation is two. In general, horizontal whitespace should be used to separate distinct conceptual \"tokens\". Do not cram all of the characters in an expression together without any horizontal whitespace. There should be white space around binary operators. Here is an example: int a = b*c; // incorrect int a = b * c; // correct Try to use explicit parenthesis to make operator precendence explicit: int a = a < 0 && b != 0; // incorrect int a = ( ( a < 0 ) && ( b != 0 ) ); // correct int a = (a < 0) && (b != 0); // correct Sometimes there can just be too many paranthesis and just too much horizontal white space. So the third one might actually be more readable. Students will have to use their judgement. In some cases, we should not include whitespace around an operator because the operator is not delimiting two distinct conceptual \"tokens\". Here are some examples: int a = obj . field; // incorrect int a = obj.field; // correct int a = obj -> field; // incorrect int a = obj->field; // correct obj . method( b ); // incorrect obj.method( b ); // correct obj -> method( b ); // incorrect obj->method( b ); // correct 2.5. Variable Declarations There should be whitespace around the assignment operator. Here is an example: int a=3; // incorrect int a = 3; // correct If possible, consder vertically aligning the variable names and assignment operators for related variables: unsigned int a = 32; int* a_ptr = &a; Never declare multiple variables in a single statement. Always use multiple statements. Here is an example: int a, b; // incorrect int a; // correct int b; // correct 2.6. Conditional Statements if conditional statements should look like this: if ( conditional_expression0 ) { statement0; } else if ( conditional_expression1 ) { statement1; } else { statement2; } Notice the use of spaces inside the parentheses since the () tokens should be conceptually separated from the conditional expression. We personally really like this style, but can also be okay to skip this horizontal whitespace like ths: if (conditional_expression0) { statement0; } else if (conditional_expression1) { statement1; } else { statement2; } However, it is critical to be consistent! If you use curly braces for one part of an if/then/else statement you must use them for all parts of the statement. Avoid single line if statements: if ( conditional_expression0 ) return 1; // incorrect if ( conditional_expression0 ) // correct return 0; // correct 2.7. Iteration Statements for loops should look like this: for ( int i = 0; i < size; i++ ) { loop_body; } Notice the extra horizontal whitespace used to separate the parentheses from the initialization statement and the increment statement. We personally really like this style, but can also be okay to skip this horizontal whitespace like this: for (int i = 0; i < size; i++) { loop_body; } However, it is critical to be consistent! We really want the open curly brace should be on the same line as the for statement. 2.8. Function Definitions Function definitions should look like this: int foo_bar( int a, int b ) { function_body; } We encourage inserting space inside the parenthesis. We personally really like this style, but can also be okay to skip this horizontal whitespace like this: int foo_bar(int a, int b) { function_body; } However, it is critical to be consistent! Notice that for functions the open curly brace goes on its own line. Do not insert a space between the function name and the open parenthesis. So this is incorrect: // incorrect int foo_bar ( int a, int b ) { function_body; } 2.9. Function Calls Function calls should usually use whitespace inside the parenthesis. For example: int result = gcd( 10, 15 ); If there is a single argument, sometimes it may be more appropriate to eliminate the whitespace inside the parenthesis. Or if it is more readable it might be fine to do this if the arguments are very simple. int result = gcd(10,15); Again, the focus is on readability. 3. Naming 3.1. Type Names For C programs, the names of user-defined types should usually be all lowercase, use underscores ( _ ) to separate words, and use a _t suffix. typedef unsigned int uint_t; For C++ programs, the names of user-defined types should usually use CamelCase. class FooBar { ... }; When specifying pointer types, the * should be placed with the type without whitespace: int * a_ptr; // incorrect int *a_ptr; // incorrect int* a_ptr; // correct As a reminder, never declare multiple variables in a single statement. This is never allowed: int *a_ptr, *b_ptr; // not allowed! 3.2. Variable Names The names of variables should always be all lowercase with underscores ( _ ) to separate words. Do not use CamelCase for variable names. For pointers, use a _ptr or _p suffix. For data member fields, use a m_ prefix. While single letter variable names are common in the lecture examples, single letter variable names should be very rare in real code. 3.3. Function/Method Names The names of free functions and methods should always be all lowercase with underscores ( _ ) to separate words. Do not use CamelCase for function or method names. 4. Comments Though a pain to write, comments are absolutely vital to keeping our code readable. The following rules describe what you should comment and where. But remember: while comments are very important, the best code is self-documenting. Giving sensible names to types and variables is much better than using obscure names that you must then explain through comments. When writing your comments, write for your audience: the next contributor who will need to understand your code. Be generous \u2014 the next one may be you! Do not state the obvious. In particular, don't literally describe what code does, unless the behavior is nonobvious to a reader who understands C/C++ well. Instead, provide higher level comments that describe why the code does what it does, or make the code self describing. 4.1. Comment Style Use // comments. These are perfectly acceptable now in C99. Do not use the older /* */ comments. Include a space after // before starting your comment: //without space, incorrect formatting // with space, correct formatting 4.2. Comment Location Avoid trailing comments. They make lines too long and are hard to read. Prefer placing each comment on its own line whenever possible. So avoid this: if ( a > b ) { // if a is greater, subtract b c = a - b; } else { // if b is greater, subtract a c = b - a; } Prefer this instead: // if a is greater, subtract b if ( a > b ) { c = a - b; } // if b is greater, subtract a else { c = b - a; } 4.3. File Comments All files should include a \"title block\". This is a comment at the very beginning of the file which gives the name of the file and a brief description of the purpose and contents of the file. Title blocks should use the following format: //========================================================================= // foo-bar.h //========================================================================= // Description of the purpose and contents of this file. The horizontal lines used in the title block should extend exactly 74 characters (i.e., two '/' characters and 72 = characters). You do not need to duplicate comments between the .h and .cc . Often the header will have a description of the interface, and the source file will discuss the broad implementation approach. 4.4. Function Comments Almost every function declaration in the header should have comments immediately preceding it that describe what the function does and how to use it. These comments may be omitted only if the function is simple and obvious. These comments should be descriptive (\"Opens the file\") rather than imperative (\"Open the file\"); the comment describes the function, it does not tell the function what to do. In general, these comments do not describe how the function performs its task. Instead, that should be left to comments in the function definition. Every function definition in the source file should have a comment like this: //------------------------------------------------------------------------ // foo_bar() //------------------------------------------------------------------------ // optional high-level discussion of implementation approach 4.5. Old Comments Do not leave old comments in the source file. So you must remove comments that were provided by the instructors. 5. Scoping This section discusses use of local and global variables. 5.1. Local Variables Place a function's variables in the narrowest scope possible. C99 no longer requires all variables to be declared at the beginning of a function, so declare variables close to where they are initialized. 5.2. Static and Global Variables Do not use non-const static or global variables unless there is a very good reason to do so. Const global variables are allowed and should definitely be used instead of preprocessor defines. 6. C Pre-processor Using the C pre-processor should be avoided. Use of the C pre-processor should usually be limited to include guards and the UTST macros. When the C pre-processor must be used, pre-processor macro names should be in all capital letters and use an underscore ( _ ) to separate words. Do not use the C pre-processor to declare global constants. Use const global variables instead. 7. Examples Here is an example of an incorrectly formatted for loop: for (int i = 0; i < n; i ++){ a += c; } There should be a space inside the parenthesis and no space between i and ++ . There should be a space after the closing parenthesis and the open curly brace. Here is the same code formatted correctly: for ( int i = 0; i < n; i++ ) { a += c; } Here is an example of an incorrectly formatted if statement: if (a < 0 && b != 0){ c = 1 / c; } else (x % 2 == 0){ ... } There should be a space inside the parenthesis and we need extra parenthesis to make the operator precedence more explicit. We also need a space between the closing parenthesis and the open curly brace. if ( ( a < 0 ) && ( b != 0 ) ) { c = 1 / c; } else ( ( x % 2 ) == 0 ) { ... } Once we have multiple levels of nested parenthesis, it might be more readable to do something like this: if ( (a < 0) && (b != 0) ) { c = 1 / c; } else ( (x % 2) == 0 ) { ... } Here is an example of a poorly formatted return statement: void foo() { ... return bar( x ) * bar( y ); } Indentation should be used to make this more clear: void foo() { ... return bar( x ) * bar( y ); } This code does not include spaces around the assignment operator, and isn't even consistent in its formatting: double foo= b; int c =bar; double e=1; This should look like this: double foo = b; int c = bar; double e = 1; Notice how we lined up the variable names and the assignment operators vertically. Here is an example of incorrectly formatted code: int gcd(int x, int y){ while(y!=0) { if ( x < y){ int t=x; x= temp; x =y; } else x = x - y; } return x; } Here is an example of correctly formatted code: //------------------------------------------------------------------------ // gcd() //------------------------------------------------------------------------ int gcd( int x, int y ) { // iterate until GCD is found while ( y != 0 ) { if ( x < y ) { // swap x and y int temp = x; y = temp; x = y; } else { x = x - y; } } return x; }","title":"ECE C/C++ Coding Conventions"},{"location":"doc0-coding-style/#ece-cc-coding-conventions","text":"Any significant programming project will usually require developers to follow a standardized set of coding conventions. These conventions might be set by a company, the leaders of an open-source project, or simply through historical precedent. Standardized coding conventions enable code written by multiple developers to be consistent and improves readability, maintainability, and extensibility. We have developed a simple set of coding conventions for your ECE coursework that we would like you to use in all programming assignments. Keep in mind that these are just guidelines, and there may be situations where it is appropriate to defy a convention. Note that some of these conventions have been adapted from the Google C++ Style Guide . In general, anything not covered by the guidelines in this document should assume the Google style guide.","title":"ECE C/C++ Coding Conventions"},{"location":"doc0-coding-style/#1-directories-and-files","text":"This section discusses how the file tree should be organized for your project.","title":"1. Directories and Files"},{"location":"doc0-coding-style/#11-directories","text":"All header, inline, data, and source files should be in a single src directory. All tests should be a in a single tests directory. Anything other than ad-hoc testing should always be done in a separate build directory.","title":"1.1. Directories"},{"location":"doc0-coding-style/#12-file-names","text":"Files should be named in all lowercase and should use a dash ( - ) to separate words. C source files should use the .c filename extension, and C++ source files should use the .cc filename extension. Header files should use the .h filename extension, and inline files should use the .inl filename extension. Data files that contain C/C++ code and are meant to be included using the C preprocessor should use the .dat filename extension. All test programs should end in -test.c . All evaluation programs should end in -eval.c .","title":"1.2. File Names"},{"location":"doc0-coding-style/#13-header-and-inline-files","text":"All header files should be self-contained. A header should include all other headers it needs. The definitions for template and inline functions should be placed in a separate .inl file and included at the end of the header. Every header should use include guards where the name of the include guard preprocessor macro is derived directly from the filename. For example, a header file named foo-bar.h would use the following include guards: #ifndef FOO_BAR_H #define FOO_BAR_H #endif // FOO_BAR_H","title":"1.3. Header and Inline Files"},{"location":"doc0-coding-style/#2-formatting","text":"This section discusses general formatting that is common across all kinds of files.","title":"2. Formatting"},{"location":"doc0-coding-style/#21-line-length","text":"Lines in all files should in general be less than 80 characters. Using less than 74 characters is ideal since this is a natural width that enables reasonable font sizes to be used when using side-by-side code development with two listings on modern laptops and side-by-side code development with three to four listings on 24\" to 27\" monitors. Lines longer than 80 characters should be avoided unless there is a compelling reason to use longer lines to increase code quality.","title":"2.1. Line Length"},{"location":"doc0-coding-style/#22-indentation","text":"Absolutely no tabs are allowed. Only spaces are allowed for the purposes of indentation. The standard number of spaces per level of indentation is two. Here is an example: int gcd( int x, int y ) { while ( y != 0 ) { if ( x < y ) { int temp = x; y = temp; x = y; } else { x = x - y; } } return x; }","title":"2.2. Indentation"},{"location":"doc0-coding-style/#23-vertical-whitespace","text":"Vertical whitspace can and should be used to separate conceptually distinct portions of your code. A blank line within a block of code serves like a paragraph break in prose: visually separating two thoughts. Vertical whitespace should be limited to a single blank line. Do not use two or more blank lines in a row. Do not include a blank line at the beginning and end of the function body in a function definition. So this is incorrect: int foo() { stmt1; return 0; } This is correct: int foo() { stmt1; return 0; }","title":"2.3. Vertical Whitespace"},{"location":"doc0-coding-style/#24-horizontal-whitespace","text":"Absolutely no tabs are allowed. Only spaces are allowed for the purposes of indentation. The standard number of spaces per level of indentation is two. In general, horizontal whitespace should be used to separate distinct conceptual \"tokens\". Do not cram all of the characters in an expression together without any horizontal whitespace. There should be white space around binary operators. Here is an example: int a = b*c; // incorrect int a = b * c; // correct Try to use explicit parenthesis to make operator precendence explicit: int a = a < 0 && b != 0; // incorrect int a = ( ( a < 0 ) && ( b != 0 ) ); // correct int a = (a < 0) && (b != 0); // correct Sometimes there can just be too many paranthesis and just too much horizontal white space. So the third one might actually be more readable. Students will have to use their judgement. In some cases, we should not include whitespace around an operator because the operator is not delimiting two distinct conceptual \"tokens\". Here are some examples: int a = obj . field; // incorrect int a = obj.field; // correct int a = obj -> field; // incorrect int a = obj->field; // correct obj . method( b ); // incorrect obj.method( b ); // correct obj -> method( b ); // incorrect obj->method( b ); // correct","title":"2.4. Horizontal Whitespace"},{"location":"doc0-coding-style/#25-variable-declarations","text":"There should be whitespace around the assignment operator. Here is an example: int a=3; // incorrect int a = 3; // correct If possible, consder vertically aligning the variable names and assignment operators for related variables: unsigned int a = 32; int* a_ptr = &a; Never declare multiple variables in a single statement. Always use multiple statements. Here is an example: int a, b; // incorrect int a; // correct int b; // correct","title":"2.5. Variable Declarations"},{"location":"doc0-coding-style/#26-conditional-statements","text":"if conditional statements should look like this: if ( conditional_expression0 ) { statement0; } else if ( conditional_expression1 ) { statement1; } else { statement2; } Notice the use of spaces inside the parentheses since the () tokens should be conceptually separated from the conditional expression. We personally really like this style, but can also be okay to skip this horizontal whitespace like ths: if (conditional_expression0) { statement0; } else if (conditional_expression1) { statement1; } else { statement2; } However, it is critical to be consistent! If you use curly braces for one part of an if/then/else statement you must use them for all parts of the statement. Avoid single line if statements: if ( conditional_expression0 ) return 1; // incorrect if ( conditional_expression0 ) // correct return 0; // correct","title":"2.6. Conditional Statements"},{"location":"doc0-coding-style/#27-iteration-statements","text":"for loops should look like this: for ( int i = 0; i < size; i++ ) { loop_body; } Notice the extra horizontal whitespace used to separate the parentheses from the initialization statement and the increment statement. We personally really like this style, but can also be okay to skip this horizontal whitespace like this: for (int i = 0; i < size; i++) { loop_body; } However, it is critical to be consistent! We really want the open curly brace should be on the same line as the for statement.","title":"2.7. Iteration Statements"},{"location":"doc0-coding-style/#28-function-definitions","text":"Function definitions should look like this: int foo_bar( int a, int b ) { function_body; } We encourage inserting space inside the parenthesis. We personally really like this style, but can also be okay to skip this horizontal whitespace like this: int foo_bar(int a, int b) { function_body; } However, it is critical to be consistent! Notice that for functions the open curly brace goes on its own line. Do not insert a space between the function name and the open parenthesis. So this is incorrect: // incorrect int foo_bar ( int a, int b ) { function_body; }","title":"2.8. Function Definitions"},{"location":"doc0-coding-style/#29-function-calls","text":"Function calls should usually use whitespace inside the parenthesis. For example: int result = gcd( 10, 15 ); If there is a single argument, sometimes it may be more appropriate to eliminate the whitespace inside the parenthesis. Or if it is more readable it might be fine to do this if the arguments are very simple. int result = gcd(10,15); Again, the focus is on readability.","title":"2.9. Function Calls"},{"location":"doc0-coding-style/#3-naming","text":"","title":"3. Naming"},{"location":"doc0-coding-style/#31-type-names","text":"For C programs, the names of user-defined types should usually be all lowercase, use underscores ( _ ) to separate words, and use a _t suffix. typedef unsigned int uint_t; For C++ programs, the names of user-defined types should usually use CamelCase. class FooBar { ... }; When specifying pointer types, the * should be placed with the type without whitespace: int * a_ptr; // incorrect int *a_ptr; // incorrect int* a_ptr; // correct As a reminder, never declare multiple variables in a single statement. This is never allowed: int *a_ptr, *b_ptr; // not allowed!","title":"3.1. Type Names"},{"location":"doc0-coding-style/#32-variable-names","text":"The names of variables should always be all lowercase with underscores ( _ ) to separate words. Do not use CamelCase for variable names. For pointers, use a _ptr or _p suffix. For data member fields, use a m_ prefix. While single letter variable names are common in the lecture examples, single letter variable names should be very rare in real code.","title":"3.2. Variable Names"},{"location":"doc0-coding-style/#33-functionmethod-names","text":"The names of free functions and methods should always be all lowercase with underscores ( _ ) to separate words. Do not use CamelCase for function or method names.","title":"3.3. Function/Method Names"},{"location":"doc0-coding-style/#4-comments","text":"Though a pain to write, comments are absolutely vital to keeping our code readable. The following rules describe what you should comment and where. But remember: while comments are very important, the best code is self-documenting. Giving sensible names to types and variables is much better than using obscure names that you must then explain through comments. When writing your comments, write for your audience: the next contributor who will need to understand your code. Be generous \u2014 the next one may be you! Do not state the obvious. In particular, don't literally describe what code does, unless the behavior is nonobvious to a reader who understands C/C++ well. Instead, provide higher level comments that describe why the code does what it does, or make the code self describing.","title":"4. Comments"},{"location":"doc0-coding-style/#41-comment-style","text":"Use // comments. These are perfectly acceptable now in C99. Do not use the older /* */ comments. Include a space after // before starting your comment: //without space, incorrect formatting // with space, correct formatting","title":"4.1. Comment Style"},{"location":"doc0-coding-style/#42-comment-location","text":"Avoid trailing comments. They make lines too long and are hard to read. Prefer placing each comment on its own line whenever possible. So avoid this: if ( a > b ) { // if a is greater, subtract b c = a - b; } else { // if b is greater, subtract a c = b - a; } Prefer this instead: // if a is greater, subtract b if ( a > b ) { c = a - b; } // if b is greater, subtract a else { c = b - a; }","title":"4.2. Comment Location"},{"location":"doc0-coding-style/#43-file-comments","text":"All files should include a \"title block\". This is a comment at the very beginning of the file which gives the name of the file and a brief description of the purpose and contents of the file. Title blocks should use the following format: //========================================================================= // foo-bar.h //========================================================================= // Description of the purpose and contents of this file. The horizontal lines used in the title block should extend exactly 74 characters (i.e., two '/' characters and 72 = characters). You do not need to duplicate comments between the .h and .cc . Often the header will have a description of the interface, and the source file will discuss the broad implementation approach.","title":"4.3. File Comments"},{"location":"doc0-coding-style/#44-function-comments","text":"Almost every function declaration in the header should have comments immediately preceding it that describe what the function does and how to use it. These comments may be omitted only if the function is simple and obvious. These comments should be descriptive (\"Opens the file\") rather than imperative (\"Open the file\"); the comment describes the function, it does not tell the function what to do. In general, these comments do not describe how the function performs its task. Instead, that should be left to comments in the function definition. Every function definition in the source file should have a comment like this: //------------------------------------------------------------------------ // foo_bar() //------------------------------------------------------------------------ // optional high-level discussion of implementation approach","title":"4.4. Function Comments"},{"location":"doc0-coding-style/#45-old-comments","text":"Do not leave old comments in the source file. So you must remove comments that were provided by the instructors.","title":"4.5. Old Comments"},{"location":"doc0-coding-style/#5-scoping","text":"This section discusses use of local and global variables.","title":"5. Scoping"},{"location":"doc0-coding-style/#51-local-variables","text":"Place a function's variables in the narrowest scope possible. C99 no longer requires all variables to be declared at the beginning of a function, so declare variables close to where they are initialized.","title":"5.1. Local Variables"},{"location":"doc0-coding-style/#52-static-and-global-variables","text":"Do not use non-const static or global variables unless there is a very good reason to do so. Const global variables are allowed and should definitely be used instead of preprocessor defines.","title":"5.2. Static and Global Variables"},{"location":"doc0-coding-style/#6-c-pre-processor","text":"Using the C pre-processor should be avoided. Use of the C pre-processor should usually be limited to include guards and the UTST macros. When the C pre-processor must be used, pre-processor macro names should be in all capital letters and use an underscore ( _ ) to separate words. Do not use the C pre-processor to declare global constants. Use const global variables instead.","title":"6. C Pre-processor"},{"location":"doc0-coding-style/#7-examples","text":"Here is an example of an incorrectly formatted for loop: for (int i = 0; i < n; i ++){ a += c; } There should be a space inside the parenthesis and no space between i and ++ . There should be a space after the closing parenthesis and the open curly brace. Here is the same code formatted correctly: for ( int i = 0; i < n; i++ ) { a += c; } Here is an example of an incorrectly formatted if statement: if (a < 0 && b != 0){ c = 1 / c; } else (x % 2 == 0){ ... } There should be a space inside the parenthesis and we need extra parenthesis to make the operator precedence more explicit. We also need a space between the closing parenthesis and the open curly brace. if ( ( a < 0 ) && ( b != 0 ) ) { c = 1 / c; } else ( ( x % 2 ) == 0 ) { ... } Once we have multiple levels of nested parenthesis, it might be more readable to do something like this: if ( (a < 0) && (b != 0) ) { c = 1 / c; } else ( (x % 2) == 0 ) { ... } Here is an example of a poorly formatted return statement: void foo() { ... return bar( x ) * bar( y ); } Indentation should be used to make this more clear: void foo() { ... return bar( x ) * bar( y ); } This code does not include spaces around the assignment operator, and isn't even consistent in its formatting: double foo= b; int c =bar; double e=1; This should look like this: double foo = b; int c = bar; double e = 1; Notice how we lined up the variable names and the assignment operators vertically. Here is an example of incorrectly formatted code: int gcd(int x, int y){ while(y!=0) { if ( x < y){ int t=x; x= temp; x =y; } else x = x - y; } return x; } Here is an example of correctly formatted code: //------------------------------------------------------------------------ // gcd() //------------------------------------------------------------------------ int gcd( int x, int y ) { // iterate until GCD is found while ( y != 0 ) { if ( x < y ) { // swap x and y int temp = x; y = temp; x = y; } else { x = x - y; } } return x; }","title":"7. Examples"},{"location":"sec1-gcc/","text":"ECE 2400 Discussion Section Wk2: Compiling and Running C Programs This discussion section serves as gentle introduction to the basics of compiling and running C programs on the ecelinux machines. The starter code for this tutorial is provided here: https://github.com/cornell-ece2400/ece2400-sec02-2025 1. Logging Into ecelinux with VS Code As we learned in the last discussion section, we will be using the ecelinux servers for all of the programming assignments. In the last discussion section we used a terminal emulator to log into the ecelinux servers. In this discussion section, we will use VS Code to log into the ecelinux servers. VS Code provides a nice GUI for navigating the directory hierarchy on ecelinux , syntax highlighting for C/C++ programs, the ability to open many files across multiple tabs, and an integrated terminal for running shell commands. Note, if you have already installed VS Code on your laptop, then you should feel free to use your laptop for this discussion section. However, if you have not already installed VS Code on your laptop and verified it works, then please use the workstations in 225 Upson or find a partner. We do not have time to help you setup VS Code on your own laptop in this discussion section. For a full tutorial on using VS Code with ecelinux, follow this tutorial . 2. Before You Begin The GitHub repo provides a quick checklist you should follow to download and setup the starter code: Be able to connect to ECELinux with VS Code (see tutorial ) Set up ssh with GitHub (we did this in last week's discussion section) git clone git@github.com:cornell-ece2400/ece2400-sec02-2025.git ece2400-sec02 this repo to ecelinux OPTIONAL BUT RECOMMENDED: Install clangd extension on the remote host Open the repo with VS Code on ecelinux, by clicking File > Open Folder . Choose ece2400-sec02 3. Compiling and Running a Single-File C Program We will begin by writing a single-file C program to calculate the average of two integers similar to what we have studied in lecture. We have provided you with a template in the avg-main.c file. Edit the avg-main.c file to include an appropriate implementation of the avg function. #include <stdio.h> int avg(int x, int y) { int sum = x + y; return sum / 2; } int main() { int a = 10; int b = 20; int c = avg(a, b); printf(\"average of %d and %d is %d\\n\", a, b, c); return 0; } We use a compiler to translate the C source code into an executable binary (i.e., the actual sequence of bits) that the machine can understand. In this discussion we will be using the GNU C compiler ( gcc ), but you could use clang too. Let's go ahead and give this a try: $ pwd # Should be ece2400-sec02 $ gcc -Wall -o avg-main src/avg-main.c The gcc command takes as input the C source file to compile and the command line option -o is used to specify the output exectutable binary (i.e., the file with the machine instructions). We also use the -Wall command line option to report all warnings. After running the gcc command you should see a new avg-main file in the directory. We can execute this binary by simply calling it as any other Linux command. However, notice the error message we received: src/avg-main.c: In function \u2018avg\u2019: src/avg-main.c:5:1: warning: control reaches end of non-void function [-Wreturn-type] 5 | } We need to fill in the rest of the code. Open the code with code src/avg-main.c and fill in that function. Then, we can check that it works: $ pwd # Should be ece2400-sec02 $ gcc -Wall -o avg-main src/avg-main.c $ ./avg-main average of 10 and 20 is 15 Recall that a single dot ( . ) always refers to the current working directory. Essentially we are telling Linux that we want to run the executable binary named avg-main which is located in the current working directory. It can be tedious to to have to carefully enter the correct commands on the command line every time we want to compile a C source file into an executable binary. In the next discussion section, we will explore using a build framework to automate the process of building our C programs. Before we move on, let's examine the machine instructions using the objdump command. $ objdump -dC avg-main | less The objdump command takes an executable binary and shows you the machine instructions in a human readable format. We are piping it through less so we can scroll through the output. Try and find how many machine instructions are used to implement the avg function. Does it seem like the compiler generated optimized code or unoptimized code? You can exit less by pressing the q key. Let's recompile our program with optimizations. We can do this by specifying -O3 (optimization level 3). $ gcc -Wall -O3 -o avg-main src/avg-main.c $ objdump -dC avg-main | less Now how many machine instructions are used to implement the avg function? 4. Compiling and Running a Multi-File C Program C programs are almost never contained in a single source file. They require many files which must be individually compiled and then linked together. Linking is the process of merging together different binary files each with its own set of machine instructions. To illustrate this process we will experiment with a function to square a given integer. Our project will include three files: include/square.h : header file with function prototype for square function src/square.c : source file with function definition for square function src/square-adhoc.c : adhoc test of square function which contains main We will compile the square.c and square-adhoc.c files into their own object files and then link these object files into a complete executable binary. An object file is like a chunk of machine instructions. We cannot execute an object file directly, because they contain only part of the entire program. However, linking the object files together creates an executable binary. Start by inspecting the header file include/square.h . Header files are the key to multi-file C programs. The square-adhoc.c source file needs to call the square function, but the square function is in a different source file. When we compile the square-adhoc.c source file, how will the compiler know that the square function exists to ensure the programmer is not accidentally calling an undefined function? How will the compiler know what parameters the square function takes, so it can perform type checking? The square-adhoc.c source file cannot directly include square.c since that would result in the same function being compiled twice into two different object files (which would cause a linker error). What we need to do is have a way to tell square-adhoc.c the square function prototype (i.e., the interface of the function including its name, parameter list, and return type) but not the square function definition . We do this with a function declaration . A function definition specifies both the function prototype (interface) and the implementation at the same time, while a function declaration just specifies the function prototype without the implementation. A header file contains all of the function declarations but no function definitions. All of the function definitions are placed in a source file that goes along with the header file. If we want to call a function that is defined in a different source file, then we simply use the #include directive to include the appropriate header file. The linker will take care of making sure the machine instructions corresponding to every function definition are linked together into the executable binary. We have provided you the square.h file with the the following contents: int square( int x ); We have provided you with a template for the square.c file. Edit src/square.c file to include an appropriate implementation of the square function. #include \"square.h\" int square(int x) { return x * x; } Notice how our square.c file includes the corresponding square.h file. This is best practice which follows the course coding conventions. Finally, take a look at the provided square-adhoc.c file: #include \"square.h\" #include <stdio.h> int main() { int a = 10; int b = square(a); printf(\"square of %d is %d\\n\", a, b); return 0; } Go ahead an fill in the implementation for square() . Then, let's compile square.c and square-adhoc.c into their corresponding object files: $ pwd # Should be ece2400-sec02 $ gcc -Iinclude -Wall -c -o square.o src/square.c $ gcc -Iinclude -Wall -c -o square-adhoc.o src/square-adhoc.c We use the -c command line option to indicate that gcc should create an object file as opposed to a complete executable binary. An object file is just a piece of machine instructions. Again, we cannot actually execute an object file; we need to link multiple object files together to create a complete executable binary. We usually use the .o filename extension to indicate that these files are object files. Let's link these two object files together to create a complete executable binary that we can actually run: $ gcc -Wall -o square-adhoc square.o square-adhoc.o Notice that the complete executable binary contains all of the machine instructions for both the square and main functions along with a bunch of additional system-level code (e.g., for the printf function). Let's go ahead and run the executable binary. $ ./square-adhoc This of course begs the question. If we can compile a project with multiple files simply by specifying all of the files on the command line, then why did we learn about how to: (1) compile each file individually into an object file; and (2) link these object files together? For small projects with just 2-3 files there is no need to use object files. However, in a project with thousands of files, specifying all files on a single command line will cause each recompilation to take a very long fixed amount of time---potentially hours. Using object files enables modular compilation. In modular compilation , we only need to recompile those source files what have changed. We can simply reuse the previously compiled object files for those source files that have not changed. Modulary compilation can drastically reduce recompile times, so that it is proportional to just how many changes you have made to the source files (e.g. less than a second). One challenge with modular compilation is it drastically increases the build complexity. In the next discussion section, we will explore using a build framework to automate the process of modular compilation for complex C programs. 5. Automation with CMake CMake is a tool that exists to essentially automate the process we just experimented with. It also assists in making your build system more portable to different operating systems. For example, Windows does not have GNU Make , so it uses Visual Studio solutions . CMake can even use the Ninja build system. In short, CMake is a higher level scripting tool to manage how your C code is built. Consequently, writing your own CMake scripts ( CMakeLists.txt ) can be difficult and CMake itself is not well documented. Nonetheless, CMake makes the building process automated and very portable when done correctly. If you want more information, investigate the CMakeLists.txt file. In this tutorial, we will only show you how to run our CMake project---not make new ones. With that said, let's rebuild the project using CMake: pwd # Should be ece2400-sec02 mkdir -p build cd build cmake .. If that worked, you should see Build files have been written to: /home/netid/ece2400-sec02/build . We have not actually built the project yet. CMake simply establishes a database of how to build our object files, and how they are interdependent. For example, let's take a look at compile_commands.json : $ cat compile_commands.json { \"directory\": \"/home/netid/ece2400-sec02/build/src\", \"command\": \"/usr/bin/cc -I/home/netid/ece2400-sec02/include -o CMakeFiles/sec02-lib.dir/square.c.o -c /home/netid/ece2400-sec02/src/square.c\", \"file\": \"/home/netid/ece2400-sec02/src/square.c\" }, { \"directory\": \"/home/netid/ece2400-sec02/build/src\", \"command\": \"/usr/bin/cc -I/home/netid/ece2400-sec02/include -o CMakeFiles/square-adhoc.dir/square-adhoc.c.o -c /home/netid/ece2400-sec02/src/square-adhoc.c\", \"file\": \"/home/netid/ece2400-sec02/src/square-adhoc.c\" }, { \"directory\": \"/home/netid/ece2400-sec02/build/src\", \"command\": \"/usr/bin/cc -I/home/netid/ece2400-sec02/include -o CMakeFiles/avg-main.dir/avg-main.c.o -c /home/netid/ece2400-sec02/src/avg-main.c\", \"file\": \"/home/netid/ece2400-sec02/src/avg-main.c\" } It may not seem impressive that CMake just generates the same compile commands that we ran by hand. However, it would be infeasible to manage these commands for thousands of object files everytime we make a change (like changing optimization level). To execute all the build commands, just run make in the build directory: pwd # Should be ece2400-sec02/build make To reiterate, cmake generates the files needed to run make (GNU Make). If it worked, you should see the executable programs ece2400-sec02/build/src/square-adhoc and ece2400-sec02/build/src/avg-main . Try running them, and make sure they work the same. Notice that ece2400-sec02/build/src is a different directory than ece2400-sec02/src . The former holds our executables, and the latter is where the source code is located. CMake by default makes the build directory mirror the source file tree. 6. To-Do On Your Own 6.1. Try clangd One benefit of using CMake is that it makes using clangd very easy. Simply install the clangd extension on the remote host in VS Code. Then, your code editor should provide helpful auto-corrections as you write your code. Clangd is the number one most useful tool when managing a gigantic codebase, so you may want to read into its capabilities: https://clangd.llvm.org/ . 6.2. Add a new source file If you have time, create a new source file named avg3-main.c in the ${HOME}/ece2400-sec02/src directory that contains an avg3 function. This function should calculate the average of three values instead of just two. Modify the main function to properly call your updated function. Finally, add your binary to src/CMakeLists.txt . Compile your new program with the same build script and run it to verify it calculates the average correctly.","title":"ECE 2400 Discussion Section Wk2: Compiling and Running C Programs"},{"location":"sec1-gcc/#ece-2400-discussion-section-wk2-compiling-and-running-c-programs","text":"This discussion section serves as gentle introduction to the basics of compiling and running C programs on the ecelinux machines. The starter code for this tutorial is provided here: https://github.com/cornell-ece2400/ece2400-sec02-2025","title":"ECE 2400 Discussion Section Wk2: Compiling and Running C Programs"},{"location":"sec1-gcc/#1-logging-into-ecelinux-with-vs-code","text":"As we learned in the last discussion section, we will be using the ecelinux servers for all of the programming assignments. In the last discussion section we used a terminal emulator to log into the ecelinux servers. In this discussion section, we will use VS Code to log into the ecelinux servers. VS Code provides a nice GUI for navigating the directory hierarchy on ecelinux , syntax highlighting for C/C++ programs, the ability to open many files across multiple tabs, and an integrated terminal for running shell commands. Note, if you have already installed VS Code on your laptop, then you should feel free to use your laptop for this discussion section. However, if you have not already installed VS Code on your laptop and verified it works, then please use the workstations in 225 Upson or find a partner. We do not have time to help you setup VS Code on your own laptop in this discussion section. For a full tutorial on using VS Code with ecelinux, follow this tutorial .","title":"1. Logging Into ecelinux with VS Code"},{"location":"sec1-gcc/#2-before-you-begin","text":"The GitHub repo provides a quick checklist you should follow to download and setup the starter code: Be able to connect to ECELinux with VS Code (see tutorial ) Set up ssh with GitHub (we did this in last week's discussion section) git clone git@github.com:cornell-ece2400/ece2400-sec02-2025.git ece2400-sec02 this repo to ecelinux OPTIONAL BUT RECOMMENDED: Install clangd extension on the remote host Open the repo with VS Code on ecelinux, by clicking File > Open Folder . Choose ece2400-sec02","title":"2. Before You Begin"},{"location":"sec1-gcc/#3-compiling-and-running-a-single-file-c-program","text":"We will begin by writing a single-file C program to calculate the average of two integers similar to what we have studied in lecture. We have provided you with a template in the avg-main.c file. Edit the avg-main.c file to include an appropriate implementation of the avg function. #include <stdio.h> int avg(int x, int y) { int sum = x + y; return sum / 2; } int main() { int a = 10; int b = 20; int c = avg(a, b); printf(\"average of %d and %d is %d\\n\", a, b, c); return 0; } We use a compiler to translate the C source code into an executable binary (i.e., the actual sequence of bits) that the machine can understand. In this discussion we will be using the GNU C compiler ( gcc ), but you could use clang too. Let's go ahead and give this a try: $ pwd # Should be ece2400-sec02 $ gcc -Wall -o avg-main src/avg-main.c The gcc command takes as input the C source file to compile and the command line option -o is used to specify the output exectutable binary (i.e., the file with the machine instructions). We also use the -Wall command line option to report all warnings. After running the gcc command you should see a new avg-main file in the directory. We can execute this binary by simply calling it as any other Linux command. However, notice the error message we received: src/avg-main.c: In function \u2018avg\u2019: src/avg-main.c:5:1: warning: control reaches end of non-void function [-Wreturn-type] 5 | } We need to fill in the rest of the code. Open the code with code src/avg-main.c and fill in that function. Then, we can check that it works: $ pwd # Should be ece2400-sec02 $ gcc -Wall -o avg-main src/avg-main.c $ ./avg-main average of 10 and 20 is 15 Recall that a single dot ( . ) always refers to the current working directory. Essentially we are telling Linux that we want to run the executable binary named avg-main which is located in the current working directory. It can be tedious to to have to carefully enter the correct commands on the command line every time we want to compile a C source file into an executable binary. In the next discussion section, we will explore using a build framework to automate the process of building our C programs. Before we move on, let's examine the machine instructions using the objdump command. $ objdump -dC avg-main | less The objdump command takes an executable binary and shows you the machine instructions in a human readable format. We are piping it through less so we can scroll through the output. Try and find how many machine instructions are used to implement the avg function. Does it seem like the compiler generated optimized code or unoptimized code? You can exit less by pressing the q key. Let's recompile our program with optimizations. We can do this by specifying -O3 (optimization level 3). $ gcc -Wall -O3 -o avg-main src/avg-main.c $ objdump -dC avg-main | less Now how many machine instructions are used to implement the avg function?","title":"3. Compiling and Running a Single-File C Program"},{"location":"sec1-gcc/#4-compiling-and-running-a-multi-file-c-program","text":"C programs are almost never contained in a single source file. They require many files which must be individually compiled and then linked together. Linking is the process of merging together different binary files each with its own set of machine instructions. To illustrate this process we will experiment with a function to square a given integer. Our project will include three files: include/square.h : header file with function prototype for square function src/square.c : source file with function definition for square function src/square-adhoc.c : adhoc test of square function which contains main We will compile the square.c and square-adhoc.c files into their own object files and then link these object files into a complete executable binary. An object file is like a chunk of machine instructions. We cannot execute an object file directly, because they contain only part of the entire program. However, linking the object files together creates an executable binary. Start by inspecting the header file include/square.h . Header files are the key to multi-file C programs. The square-adhoc.c source file needs to call the square function, but the square function is in a different source file. When we compile the square-adhoc.c source file, how will the compiler know that the square function exists to ensure the programmer is not accidentally calling an undefined function? How will the compiler know what parameters the square function takes, so it can perform type checking? The square-adhoc.c source file cannot directly include square.c since that would result in the same function being compiled twice into two different object files (which would cause a linker error). What we need to do is have a way to tell square-adhoc.c the square function prototype (i.e., the interface of the function including its name, parameter list, and return type) but not the square function definition . We do this with a function declaration . A function definition specifies both the function prototype (interface) and the implementation at the same time, while a function declaration just specifies the function prototype without the implementation. A header file contains all of the function declarations but no function definitions. All of the function definitions are placed in a source file that goes along with the header file. If we want to call a function that is defined in a different source file, then we simply use the #include directive to include the appropriate header file. The linker will take care of making sure the machine instructions corresponding to every function definition are linked together into the executable binary. We have provided you the square.h file with the the following contents: int square( int x ); We have provided you with a template for the square.c file. Edit src/square.c file to include an appropriate implementation of the square function. #include \"square.h\" int square(int x) { return x * x; } Notice how our square.c file includes the corresponding square.h file. This is best practice which follows the course coding conventions. Finally, take a look at the provided square-adhoc.c file: #include \"square.h\" #include <stdio.h> int main() { int a = 10; int b = square(a); printf(\"square of %d is %d\\n\", a, b); return 0; } Go ahead an fill in the implementation for square() . Then, let's compile square.c and square-adhoc.c into their corresponding object files: $ pwd # Should be ece2400-sec02 $ gcc -Iinclude -Wall -c -o square.o src/square.c $ gcc -Iinclude -Wall -c -o square-adhoc.o src/square-adhoc.c We use the -c command line option to indicate that gcc should create an object file as opposed to a complete executable binary. An object file is just a piece of machine instructions. Again, we cannot actually execute an object file; we need to link multiple object files together to create a complete executable binary. We usually use the .o filename extension to indicate that these files are object files. Let's link these two object files together to create a complete executable binary that we can actually run: $ gcc -Wall -o square-adhoc square.o square-adhoc.o Notice that the complete executable binary contains all of the machine instructions for both the square and main functions along with a bunch of additional system-level code (e.g., for the printf function). Let's go ahead and run the executable binary. $ ./square-adhoc This of course begs the question. If we can compile a project with multiple files simply by specifying all of the files on the command line, then why did we learn about how to: (1) compile each file individually into an object file; and (2) link these object files together? For small projects with just 2-3 files there is no need to use object files. However, in a project with thousands of files, specifying all files on a single command line will cause each recompilation to take a very long fixed amount of time---potentially hours. Using object files enables modular compilation. In modular compilation , we only need to recompile those source files what have changed. We can simply reuse the previously compiled object files for those source files that have not changed. Modulary compilation can drastically reduce recompile times, so that it is proportional to just how many changes you have made to the source files (e.g. less than a second). One challenge with modular compilation is it drastically increases the build complexity. In the next discussion section, we will explore using a build framework to automate the process of modular compilation for complex C programs.","title":"4. Compiling and Running a Multi-File C Program"},{"location":"sec1-gcc/#5-automation-with-cmake","text":"CMake is a tool that exists to essentially automate the process we just experimented with. It also assists in making your build system more portable to different operating systems. For example, Windows does not have GNU Make , so it uses Visual Studio solutions . CMake can even use the Ninja build system. In short, CMake is a higher level scripting tool to manage how your C code is built. Consequently, writing your own CMake scripts ( CMakeLists.txt ) can be difficult and CMake itself is not well documented. Nonetheless, CMake makes the building process automated and very portable when done correctly. If you want more information, investigate the CMakeLists.txt file. In this tutorial, we will only show you how to run our CMake project---not make new ones. With that said, let's rebuild the project using CMake: pwd # Should be ece2400-sec02 mkdir -p build cd build cmake .. If that worked, you should see Build files have been written to: /home/netid/ece2400-sec02/build . We have not actually built the project yet. CMake simply establishes a database of how to build our object files, and how they are interdependent. For example, let's take a look at compile_commands.json : $ cat compile_commands.json { \"directory\": \"/home/netid/ece2400-sec02/build/src\", \"command\": \"/usr/bin/cc -I/home/netid/ece2400-sec02/include -o CMakeFiles/sec02-lib.dir/square.c.o -c /home/netid/ece2400-sec02/src/square.c\", \"file\": \"/home/netid/ece2400-sec02/src/square.c\" }, { \"directory\": \"/home/netid/ece2400-sec02/build/src\", \"command\": \"/usr/bin/cc -I/home/netid/ece2400-sec02/include -o CMakeFiles/square-adhoc.dir/square-adhoc.c.o -c /home/netid/ece2400-sec02/src/square-adhoc.c\", \"file\": \"/home/netid/ece2400-sec02/src/square-adhoc.c\" }, { \"directory\": \"/home/netid/ece2400-sec02/build/src\", \"command\": \"/usr/bin/cc -I/home/netid/ece2400-sec02/include -o CMakeFiles/avg-main.dir/avg-main.c.o -c /home/netid/ece2400-sec02/src/avg-main.c\", \"file\": \"/home/netid/ece2400-sec02/src/avg-main.c\" } It may not seem impressive that CMake just generates the same compile commands that we ran by hand. However, it would be infeasible to manage these commands for thousands of object files everytime we make a change (like changing optimization level). To execute all the build commands, just run make in the build directory: pwd # Should be ece2400-sec02/build make To reiterate, cmake generates the files needed to run make (GNU Make). If it worked, you should see the executable programs ece2400-sec02/build/src/square-adhoc and ece2400-sec02/build/src/avg-main . Try running them, and make sure they work the same. Notice that ece2400-sec02/build/src is a different directory than ece2400-sec02/src . The former holds our executables, and the latter is where the source code is located. CMake by default makes the build directory mirror the source file tree.","title":"5. Automation with CMake"},{"location":"sec1-gcc/#6-to-do-on-your-own","text":"","title":"6. To-Do On Your Own"},{"location":"sec1-gcc/#61-try-clangd","text":"One benefit of using CMake is that it makes using clangd very easy. Simply install the clangd extension on the remote host in VS Code. Then, your code editor should provide helpful auto-corrections as you write your code. Clangd is the number one most useful tool when managing a gigantic codebase, so you may want to read into its capabilities: https://clangd.llvm.org/ .","title":"6.1. Try clangd"},{"location":"sec1-gcc/#62-add-a-new-source-file","text":"If you have time, create a new source file named avg3-main.c in the ${HOME}/ece2400-sec02/src directory that contains an avg3 function. This function should calculate the average of three values instead of just two. Modify the main function to properly call your updated function. Finally, add your binary to src/CMakeLists.txt . Compile your new program with the same build script and run it to verify it calculates the average correctly.","title":"6.2. Add a new source file"},{"location":"sec2-cmake/","text":"ECE2400 Section 3: C Build and Test Frameworks In the previous discussion section, you learned how to explicitly compile and run C programs from the command line. You learned how to use the GNU C Compiler ( gcc ) to compile both a single-file program, as well as a multi-file program that calculated the square of an integer. You probably noticed that it can be tedious to have to carefully enter the correct commands on the command line. In this discussion section, we will more closely exam the GNU Make build framework and CMake build framework to automate the C build process. 1. Logging Into ecelinux with VS Code Once again, we will be using VS Code to log into the ecelinux servers: Start VS Code Use View > Command Palette to execute Remote-SSH: Connect Current Window to Host... Enter netid@ecelinux.ece.cornell.edu Use View > Explorer to open folder on ecelinux Use View > Terminal to open terminal on ecelinux Now clone the GitHub repo using the following commands: $ git clone git@github.com:cornell-ece2400/ece2400-sec02-2025 ece2400-sec03 $ cd ece2400-sec03 $ tree The directory includes the following files: avg-main.c : source and main for single-file avg program square.h : header file for the square function square.c : source file for the square function square-adhoc.c : test driver for square function 2. Using Makefiles to Compile C Programs Let's remind ourselves how to explicitly compile and run a single-file C program on the command line: $ gcc -Wall -o avg-main src/avg-main.c $ ./avg-main Let's now remove the binary so we are back to a clean directory: $ rm -r avg-main We will start by using a new tool called GNU Make which was specifically designed to help automate the process of building C programs. The key to using make is developing a Makefile . A Makefile is a plain text file which contains a list of rules which together specify how to execute commands to accomplish some task. Each rule has the following syntax: target : prerequisite0 prerequisite1 prerequisite2 <TAB>command A rule show specify how to generate the target file using the list of prerequisite files combined with a shell command. make is smart enough to know it should re-make the target if any of the prerequisites change, and it also knows that if one of the prerequisites does not exist, then it should try to build it first. This process occurs recursively. It is very important to note that make requires commands in a rule to start with a real TAB character. So you should not type the letters <TAB> , but you should instead press the TAB key and verify that it has inserted a real TAB character (i.e., if you move the left/right arrows the cursor should jump back and forth across the TAB). This is the only time in the course where you should use a real TAB character as opposed to spaces. Let's create a simple Makefile to compile a single-file C program. Use VS Code to create a file named Makefile with the following content: avg-main: src/avg-main.c <TAB>gcc -Wall -o avg-main $^ clean: <TAB>rm -rf avg-main In this case $^ refers to src/avg-main.c . See GNU Automatic Variables for more info. We can use the newly created Makefile like this: $ make avg-main $ ./avg-main make will by default use the Makefile in the current directory. make takes a command line argument specifying what you want \"make\". make will look at all of the rules in the Makefile to find a rule that specifies how to make the avg-main executable. It will then check to make sure the prerequisites exist and that they are up-to-date. If that condition is met, it will run the command specified in the rule for avg-main . In this case, that command is gcc . make will output to the terminal every command it runs, so you should see it output the command line which uses gcc to generate the avg-main executable. Try running make again: $ make avg-main $ ./avg-main make detects that the prerequisite (i.e., src/avg-main.c ) has not changed and so it does not recompile the executable. Now let's try making a change in the avg-main.c source file. Modify the printf statement as follows: printf(\"avg( %d, %d ) == %d\\n\", a, b, c ); You can recompile and re-execute the program like this: $ make avg-main $ ./avg-main In this case, make detects that the prerequisite has changed, and hence recompile the executable. The ability to automatically track dependencies and recompile only what is necessary is the key benefit of using a tool like GNU Make. Makefiles can also include targets which are not actually files. Our example Makefile includes a clean target which will delete any generated executables. Let's clean up our directory like this: $ ls $ make clean $ ls 3. Using CMake to Generate Makefiles for Compiling C Programs While using make can help automate the build process, the corresponding Makefiles can grow to be incredibly complicated. Creating and maintaining these Makefiles can involve significant effort. It can be particularly challenging to ensure all of the dependencies between the various source and header files are always correctly captured in the Makefile . New tools have been developed to help automate the process of managing Makefiles (which in turn automate the build process). Automation is the key to effective software development methodologies. In this course, we will be using CMake as a key step in our build framework. CMake takes as input a simple CMakeLists.txt file and generates a more sophisticated Makefile to use. Before getting started let's remove any files we have generated and also remove the Makefile we developed in the previous section. $ make clean $ rm -f Makefile Let's inspect the provided CMakeLists.txt that can be used to generate a Makefile which will in turn be used to compile a single-file C program: cat CMakeLists.txt cmake_minimum_required(VERSION 3.1) project(sec02 C) set(CMAKE_EXPORT_COMPILE_COMMANDS ON) include_directories(include) add_subdirectory(src) Line 1 specifies the CMake version we are assuming, and line 2 specifies that we will be using CMake with a C project called sec02 . Line 3 states that we will be generating the database file, so that clangd can work. The last two lines tell CMake where our code and header files live ( src/ and include/ , respectively). Notice, that there is another required CMakeLists.txt inside src/ with more information about which source files to use: cat src/CMakeLists.txt add_library(sec02-lib square.c ) add_executable(square-adhoc square-adhoc.c) target_link_libraries(square-adhoc PUBLIC sec02-lib ) add_executable(avg-main avg-main.c) Now, let's use CMake to generate a GNU Makefile. $ cmake . $ ls $ less Makefile NOTE: THERE IS A DOT AFTER cmake ! The cmake command will by default use the CMakeLists.txt in the directory given as a command line argument. CMake takes care of figuring out what C compilers are available and then generating the Makefile appropriately. You can see that CMake has automatically generated a pretty sophisticated Makefile . Let's go ahead and use this Makefile to build avg-main . $ make avg-main $ ./avg-main CMake will automatically create some useful targets like clean . $ make clean With some practice, writing a CMakeLists.txt is simpler than writing a Makefile , especially when we start working with a large codebase.","title":"ECE2400 Section 3: C Build and Test Frameworks"},{"location":"sec2-cmake/#ece2400-section-3-c-build-and-test-frameworks","text":"In the previous discussion section, you learned how to explicitly compile and run C programs from the command line. You learned how to use the GNU C Compiler ( gcc ) to compile both a single-file program, as well as a multi-file program that calculated the square of an integer. You probably noticed that it can be tedious to have to carefully enter the correct commands on the command line. In this discussion section, we will more closely exam the GNU Make build framework and CMake build framework to automate the C build process.","title":"ECE2400 Section 3: C Build and Test Frameworks"},{"location":"sec2-cmake/#1-logging-into-ecelinux-with-vs-code","text":"Once again, we will be using VS Code to log into the ecelinux servers: Start VS Code Use View > Command Palette to execute Remote-SSH: Connect Current Window to Host... Enter netid@ecelinux.ece.cornell.edu Use View > Explorer to open folder on ecelinux Use View > Terminal to open terminal on ecelinux Now clone the GitHub repo using the following commands: $ git clone git@github.com:cornell-ece2400/ece2400-sec02-2025 ece2400-sec03 $ cd ece2400-sec03 $ tree The directory includes the following files: avg-main.c : source and main for single-file avg program square.h : header file for the square function square.c : source file for the square function square-adhoc.c : test driver for square function","title":"1. Logging Into ecelinux with VS Code"},{"location":"sec2-cmake/#2-using-makefiles-to-compile-c-programs","text":"Let's remind ourselves how to explicitly compile and run a single-file C program on the command line: $ gcc -Wall -o avg-main src/avg-main.c $ ./avg-main Let's now remove the binary so we are back to a clean directory: $ rm -r avg-main We will start by using a new tool called GNU Make which was specifically designed to help automate the process of building C programs. The key to using make is developing a Makefile . A Makefile is a plain text file which contains a list of rules which together specify how to execute commands to accomplish some task. Each rule has the following syntax: target : prerequisite0 prerequisite1 prerequisite2 <TAB>command A rule show specify how to generate the target file using the list of prerequisite files combined with a shell command. make is smart enough to know it should re-make the target if any of the prerequisites change, and it also knows that if one of the prerequisites does not exist, then it should try to build it first. This process occurs recursively. It is very important to note that make requires commands in a rule to start with a real TAB character. So you should not type the letters <TAB> , but you should instead press the TAB key and verify that it has inserted a real TAB character (i.e., if you move the left/right arrows the cursor should jump back and forth across the TAB). This is the only time in the course where you should use a real TAB character as opposed to spaces. Let's create a simple Makefile to compile a single-file C program. Use VS Code to create a file named Makefile with the following content: avg-main: src/avg-main.c <TAB>gcc -Wall -o avg-main $^ clean: <TAB>rm -rf avg-main In this case $^ refers to src/avg-main.c . See GNU Automatic Variables for more info. We can use the newly created Makefile like this: $ make avg-main $ ./avg-main make will by default use the Makefile in the current directory. make takes a command line argument specifying what you want \"make\". make will look at all of the rules in the Makefile to find a rule that specifies how to make the avg-main executable. It will then check to make sure the prerequisites exist and that they are up-to-date. If that condition is met, it will run the command specified in the rule for avg-main . In this case, that command is gcc . make will output to the terminal every command it runs, so you should see it output the command line which uses gcc to generate the avg-main executable. Try running make again: $ make avg-main $ ./avg-main make detects that the prerequisite (i.e., src/avg-main.c ) has not changed and so it does not recompile the executable. Now let's try making a change in the avg-main.c source file. Modify the printf statement as follows: printf(\"avg( %d, %d ) == %d\\n\", a, b, c ); You can recompile and re-execute the program like this: $ make avg-main $ ./avg-main In this case, make detects that the prerequisite has changed, and hence recompile the executable. The ability to automatically track dependencies and recompile only what is necessary is the key benefit of using a tool like GNU Make. Makefiles can also include targets which are not actually files. Our example Makefile includes a clean target which will delete any generated executables. Let's clean up our directory like this: $ ls $ make clean $ ls","title":"2. Using Makefiles to Compile C Programs"},{"location":"sec2-cmake/#3-using-cmake-to-generate-makefiles-for-compiling-c-programs","text":"While using make can help automate the build process, the corresponding Makefiles can grow to be incredibly complicated. Creating and maintaining these Makefiles can involve significant effort. It can be particularly challenging to ensure all of the dependencies between the various source and header files are always correctly captured in the Makefile . New tools have been developed to help automate the process of managing Makefiles (which in turn automate the build process). Automation is the key to effective software development methodologies. In this course, we will be using CMake as a key step in our build framework. CMake takes as input a simple CMakeLists.txt file and generates a more sophisticated Makefile to use. Before getting started let's remove any files we have generated and also remove the Makefile we developed in the previous section. $ make clean $ rm -f Makefile Let's inspect the provided CMakeLists.txt that can be used to generate a Makefile which will in turn be used to compile a single-file C program: cat CMakeLists.txt cmake_minimum_required(VERSION 3.1) project(sec02 C) set(CMAKE_EXPORT_COMPILE_COMMANDS ON) include_directories(include) add_subdirectory(src) Line 1 specifies the CMake version we are assuming, and line 2 specifies that we will be using CMake with a C project called sec02 . Line 3 states that we will be generating the database file, so that clangd can work. The last two lines tell CMake where our code and header files live ( src/ and include/ , respectively). Notice, that there is another required CMakeLists.txt inside src/ with more information about which source files to use: cat src/CMakeLists.txt add_library(sec02-lib square.c ) add_executable(square-adhoc square-adhoc.c) target_link_libraries(square-adhoc PUBLIC sec02-lib ) add_executable(avg-main avg-main.c) Now, let's use CMake to generate a GNU Makefile. $ cmake . $ ls $ less Makefile NOTE: THERE IS A DOT AFTER cmake ! The cmake command will by default use the CMakeLists.txt in the directory given as a command line argument. CMake takes care of figuring out what C compilers are available and then generating the Makefile appropriately. You can see that CMake has automatically generated a pretty sophisticated Makefile . Let's go ahead and use this Makefile to build avg-main . $ make avg-main $ ./avg-main CMake will automatically create some useful targets like clean . $ make clean With some practice, writing a CMakeLists.txt is simpler than writing a Makefile , especially when we start working with a large codebase.","title":"3. Using CMake to Generate Makefiles for Compiling C Programs"},{"location":"tut0-ecelinux/","text":"ECE Linux Server Remote Access Most of your ECE coursework will be completed remotely, by logging into the cluster of ecelinux servers. The ecelinux servers all run the Red Hat Enterprise Linux operating system with identical setups. First, you do not need to do anything to create an ecelinux account. You will be using your NetID and Cornell password to login, and an ecelinux account will be automatically created for you. Any student enrolled in an ECE class should automatically be granted access to the ecelinux servers. With that said, please reach out to the course staff if you cannot log in. Later tutorials will discuss how to use the Linux command line and the git version control system. However, this tutorial focuses on how to initially setup remote access to the ecelinux servers. First, you will connect to the Cornell VPN. Then, you will open a remote shell and log in. Any terminal emulator should do the trick, but we recommend using PowerShell on Windows or Terminal on Mac. After logging in, the tutorial will introduce Visual Studio Code (VS Code), which provides a very nice graphical interface to supplement the command line. 1. Connecting to the Cornell VPN If you are logging into the ecelinux servers from an on-campus network (i.e., using the Cornell wired or wireless network), then you do not need to enable the Cornell virtual private network (VPN). However, if you are off campus, then you will need to connect the Cornell VPN whenever you want to use the ecelinux servers. The VPN provides an extra layer of security, and more information about the Cornell VPN is available here: https://it.cornell.edu/landing-page-kba/2605/5273 Simply follow the instructions at the above link to install the Cisco VPN software for your operating system. Basic troubleshooting steps can be found at the following link. https://it.cornell.edu/landing-page-kba/2605/823 Logging into the VPN requires (1) your NetID, (2) your password, and (3) your Duo Mobile authenticator. Notice in the screenshot below, then second password field labeled 'Duo'. There you will enter 'push' and clicking 'Connect' should trigger a Duo notification. 2. Remote Access via Terminal Emulator Any terminal emulator should be able to connect to ecelinux, but we recommend using PowerShell on Windows or Terminal on Mac. Both enable you to operate your computer from the command line. Moreover, they also enable secure, remote access to other systems. We will use the ssh command (short for secure shell), and then we will practice some simple actions like manipulating files. 2.1. Starting PowerShell or Mac Terminal First, you must be connected to the Cornell VPN if you are off campus. To start PowerShell, click the Start menu then search for Windows PowerShell. To start Mac Terminal, go to your Applications folder and choose Utilities > Terminal . You can also open Spotlight, type Terminal, and press enter. 2.2. Logging into ecelinux Servers with PowerShell or Mac Terminal After starting PowerShell or Mac Terminal, type in the following command at the command prompt: $ ssh <netid>@ecelinux.ece.cornell.edu Replace 'netid' with your Cornell NetID. Make sure not to enter the dollar sign---that is just the bash shell prompt. Executing this command correctly will ask you for your Cornell NetID password. If all is well, then you should be connected to the ecelinux servers. The very first time you log into the ecelinux servers you may see a warning like this: The authenticity of host \u2019ecelinux.ece.cornell.edu (128.253.51.206)\u2019 can\u2019t be established. ECDSA key fingerprint is SHA256:smwMnf9dyhs5zW5I279C5oJBrTFc5FLghIJMfBR1cxI. Are you sure you want to continue connecting (yes/no)? This is expected, and you can enter 'yes.' If you logged in successfully, your shell should look like this: $ ssh netid@ecelinux.ece.cornell.edu netid@ecelinux.ece.cornell.edu's password: ******************************************************************************* THIS SERVER IS FOR INSTRUCTIONAL USE ONLY ABSOLUTELY NO RESEARCH SHOULD BE DONE ON THIS SERVER JOBS RUNNING LONGER THAN 30 MINUTES MAY BE KILLED WITHOUT WARNING System Maintenance Tuesday and Thursday mornings between 5am and 7 am. System may reboot during these times. Faculty may request postponement of this maintenance by sending an email to itcoecis-help@cornell.edu ******************************************************************************* [netid@ecelinux-20 ~]$ 2.3. Nano Text Editor Now that you are online, let's try to use a simple command line program. Nano is a text-based editor installed on all linux machines. To experiment with nano , we will first grab a text file to edit from the internet with the wget command. $ wget https://pastebin.com/raw/xsf10vFR -O myfile.txt Notice that the file is now in on working directory: $ ls myfile.txt We can now open this file and edit it with nano : $ nano myfile.txt Notice that the editor shows most of the useful commands at the bottom of the terminal. The symbol ^ signifies the CONTROL key. To type any text you want, just move the insertion point around using your arrow keys. Let's add 'Hello ECE!' to the end of the file. To exit and save your changes, press CONTROL+X, Y to save, and then ENTER to use the same file name. Congrats! We can test that our file was updated with cat : $ cat myfile.txt Hello wget! Hello ECE! 3. Remote Access via VS Code While you can complete all your coursework with just a terminal, it is not the most productive setup. We strongly recommend using VS Code as your primary option for code development on ecelinux. VS Code runs the GUI interface on your personal computer, but executes your actions on the remote computer. This enables you to use ecelinux as if it is your own computer. All you need is VS Code plus the remote ssh extension . But first, here is more information on how to install VS Code in the first place. 3.1. Installing VS Code on Your Laptop/Workstation You can download VS Code by simply going to the main VS Code webpage: https://code.visualstudio.com There are no special steps required. However, you may want to consider disabling telemetry for security concerns. Here are some VS Code extensions you will more than likely use for your coursework: remote ssh extension C/C++ clangd for C++ Verilog HDL 3.2. Logging into ecelinux Servers with VS Code As a reminder, you must be connected to the Cornell VPN to access ecelinux off-campus. After starting VS Code, choose View > Command Palette from the menubar. Enter the command Remote-SSH: Connect Current Window to Host in the command palette: As you start typing the command, you can just click the correct option when you see it. VS Code will then ask you where to connect to. You should enter netid@ecelinux.ece.cornell.edu . Of course, replace netid with your Cornell NetID. If you are on Windows, then you may see a pop-up which says 'Windows Defender Firewall has blocked some features of this app.' This is not a problem. Simply click 'Cancel.' You may also see a drop down asking you to choose the operating system of the remote host. Choose Linux. This is the operating system of ecelinux. Now VS Code should prompt you to enter your Cornell NetID password. Logging into ecelinux with VS Code for the first time may take up to a minute or two to initialize. Once the pop up dialog box goes away and you see 'SSH: ecelinux.ece.cornell.edu' in the lower left-hand corner of VS Code, then you know you are connected to the ecelinux servers. The final step is to make sure your personal VS Code extensions are also installed on the remote host. Choose View > Extensions from the menubar. Instead of saying 'Install' it should now say 'Install in SSH: ecelinux.ece.cornell.edu.' Click this choice for the extensions you need. You should only need to do this once. 3.4. Using VS Code VS Code includes an integrated file explorer. Choose View > Explorer from the menubar. Then, click on Open Folder. VS Code will then ask you to Open File Or Folder with a default of /home/netid. Click 'OK.' You might see a pop-up which asks you 'Do you trust the authors of the files in this folder?' Since you will only be browsing your own files on the ecelinux server, it is fine to choose 'Yes, I trust the authors.' This will reload VS Code, and you should now see a file explorer in the left sidebar. You can easily browse your directory hierarchy, open files by clicking on them, create new files, and delete files. VS Code also includes an integrated terminal which will give you access to the Linux command line on the ecelinux servers. Choose Terminal > New Terminal from the menubar. You should see the same kind of Linux command line prompt that you saw when using either PowerShell or Mac Terminal. What is cool is that we can open new VS Code tabs from the command line: $ wget https://pastebin.com/raw/xsf10vFR -O mynewfile.txt $ code mynewfile.txt Notice how the text file opened in a new tab at the top, and the terminal remains at the bottom. This enables you to have easy access to editing files and the Linux command line at the same time. 3.5. Troubleshooting Remote Access via VS Code Sometimes VS Code just keeps asking you for your password forever or VS Code just hangs when you try to connect to the server. You can definitely ask the course staff for help, but you can also try to fix it on your own. The first attempt is to kill the VS Code server on the host machine (ecelinux). Choose View > Command Palette from the menubar. Enter Remote-SSH: Kill VS Code Server on Host in the command palette. The second thing to try is to delete the .vscode-server directory on the sever. How can you delete this directory if you cannot use VS Code to access the ecelinux servers? You can simply use PowerShell or Mac Terminal to log into the ecelinux servers. Once you have gained access to the Linux command line on the ecelinux servers, you can delete the .vscode-server directory like this: $ rm -rf .vscode-server Be very careful with the rm command since it can permanently delete files! Lastly, you can also try to directly log into a specific ecelinux server. Instead of logging into ecelinux.ece.cornell.edu (which automatically picks an ecelinux server for you), you can log into ecelinux-01.ece.cornell.edu , ecelinux-02.ece.cornell.edu , and so on.","title":"ECE Linux Server Remote Access"},{"location":"tut0-ecelinux/#ece-linux-server-remote-access","text":"Most of your ECE coursework will be completed remotely, by logging into the cluster of ecelinux servers. The ecelinux servers all run the Red Hat Enterprise Linux operating system with identical setups. First, you do not need to do anything to create an ecelinux account. You will be using your NetID and Cornell password to login, and an ecelinux account will be automatically created for you. Any student enrolled in an ECE class should automatically be granted access to the ecelinux servers. With that said, please reach out to the course staff if you cannot log in. Later tutorials will discuss how to use the Linux command line and the git version control system. However, this tutorial focuses on how to initially setup remote access to the ecelinux servers. First, you will connect to the Cornell VPN. Then, you will open a remote shell and log in. Any terminal emulator should do the trick, but we recommend using PowerShell on Windows or Terminal on Mac. After logging in, the tutorial will introduce Visual Studio Code (VS Code), which provides a very nice graphical interface to supplement the command line.","title":"ECE Linux Server Remote Access"},{"location":"tut0-ecelinux/#1-connecting-to-the-cornell-vpn","text":"If you are logging into the ecelinux servers from an on-campus network (i.e., using the Cornell wired or wireless network), then you do not need to enable the Cornell virtual private network (VPN). However, if you are off campus, then you will need to connect the Cornell VPN whenever you want to use the ecelinux servers. The VPN provides an extra layer of security, and more information about the Cornell VPN is available here: https://it.cornell.edu/landing-page-kba/2605/5273 Simply follow the instructions at the above link to install the Cisco VPN software for your operating system. Basic troubleshooting steps can be found at the following link. https://it.cornell.edu/landing-page-kba/2605/823 Logging into the VPN requires (1) your NetID, (2) your password, and (3) your Duo Mobile authenticator. Notice in the screenshot below, then second password field labeled 'Duo'. There you will enter 'push' and clicking 'Connect' should trigger a Duo notification.","title":"1. Connecting to the Cornell VPN"},{"location":"tut0-ecelinux/#2-remote-access-via-terminal-emulator","text":"Any terminal emulator should be able to connect to ecelinux, but we recommend using PowerShell on Windows or Terminal on Mac. Both enable you to operate your computer from the command line. Moreover, they also enable secure, remote access to other systems. We will use the ssh command (short for secure shell), and then we will practice some simple actions like manipulating files.","title":"2. Remote Access via Terminal Emulator"},{"location":"tut0-ecelinux/#21-starting-powershell-or-mac-terminal","text":"First, you must be connected to the Cornell VPN if you are off campus. To start PowerShell, click the Start menu then search for Windows PowerShell. To start Mac Terminal, go to your Applications folder and choose Utilities > Terminal . You can also open Spotlight, type Terminal, and press enter.","title":"2.1. Starting PowerShell or Mac Terminal"},{"location":"tut0-ecelinux/#22-logging-into-ecelinux-servers-with-powershell-or-mac-terminal","text":"After starting PowerShell or Mac Terminal, type in the following command at the command prompt: $ ssh <netid>@ecelinux.ece.cornell.edu Replace 'netid' with your Cornell NetID. Make sure not to enter the dollar sign---that is just the bash shell prompt. Executing this command correctly will ask you for your Cornell NetID password. If all is well, then you should be connected to the ecelinux servers. The very first time you log into the ecelinux servers you may see a warning like this: The authenticity of host \u2019ecelinux.ece.cornell.edu (128.253.51.206)\u2019 can\u2019t be established. ECDSA key fingerprint is SHA256:smwMnf9dyhs5zW5I279C5oJBrTFc5FLghIJMfBR1cxI. Are you sure you want to continue connecting (yes/no)? This is expected, and you can enter 'yes.' If you logged in successfully, your shell should look like this: $ ssh netid@ecelinux.ece.cornell.edu netid@ecelinux.ece.cornell.edu's password: ******************************************************************************* THIS SERVER IS FOR INSTRUCTIONAL USE ONLY ABSOLUTELY NO RESEARCH SHOULD BE DONE ON THIS SERVER JOBS RUNNING LONGER THAN 30 MINUTES MAY BE KILLED WITHOUT WARNING System Maintenance Tuesday and Thursday mornings between 5am and 7 am. System may reboot during these times. Faculty may request postponement of this maintenance by sending an email to itcoecis-help@cornell.edu ******************************************************************************* [netid@ecelinux-20 ~]$","title":"2.2. Logging into ecelinux Servers with PowerShell or Mac Terminal"},{"location":"tut0-ecelinux/#23-nano-text-editor","text":"Now that you are online, let's try to use a simple command line program. Nano is a text-based editor installed on all linux machines. To experiment with nano , we will first grab a text file to edit from the internet with the wget command. $ wget https://pastebin.com/raw/xsf10vFR -O myfile.txt Notice that the file is now in on working directory: $ ls myfile.txt We can now open this file and edit it with nano : $ nano myfile.txt Notice that the editor shows most of the useful commands at the bottom of the terminal. The symbol ^ signifies the CONTROL key. To type any text you want, just move the insertion point around using your arrow keys. Let's add 'Hello ECE!' to the end of the file. To exit and save your changes, press CONTROL+X, Y to save, and then ENTER to use the same file name. Congrats! We can test that our file was updated with cat : $ cat myfile.txt Hello wget! Hello ECE!","title":"2.3. Nano Text Editor"},{"location":"tut0-ecelinux/#3-remote-access-via-vs-code","text":"While you can complete all your coursework with just a terminal, it is not the most productive setup. We strongly recommend using VS Code as your primary option for code development on ecelinux. VS Code runs the GUI interface on your personal computer, but executes your actions on the remote computer. This enables you to use ecelinux as if it is your own computer. All you need is VS Code plus the remote ssh extension . But first, here is more information on how to install VS Code in the first place.","title":"3. Remote Access via VS Code"},{"location":"tut0-ecelinux/#31-installing-vs-code-on-your-laptopworkstation","text":"You can download VS Code by simply going to the main VS Code webpage: https://code.visualstudio.com There are no special steps required. However, you may want to consider disabling telemetry for security concerns. Here are some VS Code extensions you will more than likely use for your coursework: remote ssh extension C/C++ clangd for C++ Verilog HDL","title":"3.1. Installing VS Code on Your Laptop/Workstation"},{"location":"tut0-ecelinux/#32-logging-into-ecelinux-servers-with-vs-code","text":"As a reminder, you must be connected to the Cornell VPN to access ecelinux off-campus. After starting VS Code, choose View > Command Palette from the menubar. Enter the command Remote-SSH: Connect Current Window to Host in the command palette: As you start typing the command, you can just click the correct option when you see it. VS Code will then ask you where to connect to. You should enter netid@ecelinux.ece.cornell.edu . Of course, replace netid with your Cornell NetID. If you are on Windows, then you may see a pop-up which says 'Windows Defender Firewall has blocked some features of this app.' This is not a problem. Simply click 'Cancel.' You may also see a drop down asking you to choose the operating system of the remote host. Choose Linux. This is the operating system of ecelinux. Now VS Code should prompt you to enter your Cornell NetID password. Logging into ecelinux with VS Code for the first time may take up to a minute or two to initialize. Once the pop up dialog box goes away and you see 'SSH: ecelinux.ece.cornell.edu' in the lower left-hand corner of VS Code, then you know you are connected to the ecelinux servers. The final step is to make sure your personal VS Code extensions are also installed on the remote host. Choose View > Extensions from the menubar. Instead of saying 'Install' it should now say 'Install in SSH: ecelinux.ece.cornell.edu.' Click this choice for the extensions you need. You should only need to do this once.","title":"3.2. Logging into ecelinux Servers with VS Code"},{"location":"tut0-ecelinux/#34-using-vs-code","text":"VS Code includes an integrated file explorer. Choose View > Explorer from the menubar. Then, click on Open Folder. VS Code will then ask you to Open File Or Folder with a default of /home/netid. Click 'OK.' You might see a pop-up which asks you 'Do you trust the authors of the files in this folder?' Since you will only be browsing your own files on the ecelinux server, it is fine to choose 'Yes, I trust the authors.' This will reload VS Code, and you should now see a file explorer in the left sidebar. You can easily browse your directory hierarchy, open files by clicking on them, create new files, and delete files. VS Code also includes an integrated terminal which will give you access to the Linux command line on the ecelinux servers. Choose Terminal > New Terminal from the menubar. You should see the same kind of Linux command line prompt that you saw when using either PowerShell or Mac Terminal. What is cool is that we can open new VS Code tabs from the command line: $ wget https://pastebin.com/raw/xsf10vFR -O mynewfile.txt $ code mynewfile.txt Notice how the text file opened in a new tab at the top, and the terminal remains at the bottom. This enables you to have easy access to editing files and the Linux command line at the same time.","title":"3.4. Using VS Code"},{"location":"tut0-ecelinux/#35-troubleshooting-remote-access-via-vs-code","text":"Sometimes VS Code just keeps asking you for your password forever or VS Code just hangs when you try to connect to the server. You can definitely ask the course staff for help, but you can also try to fix it on your own. The first attempt is to kill the VS Code server on the host machine (ecelinux). Choose View > Command Palette from the menubar. Enter Remote-SSH: Kill VS Code Server on Host in the command palette. The second thing to try is to delete the .vscode-server directory on the sever. How can you delete this directory if you cannot use VS Code to access the ecelinux servers? You can simply use PowerShell or Mac Terminal to log into the ecelinux servers. Once you have gained access to the Linux command line on the ecelinux servers, you can delete the .vscode-server directory like this: $ rm -rf .vscode-server Be very careful with the rm command since it can permanently delete files! Lastly, you can also try to directly log into a specific ecelinux server. Instead of logging into ecelinux.ece.cornell.edu (which automatically picks an ecelinux server for you), you can log into ecelinux-01.ece.cornell.edu , ecelinux-02.ece.cornell.edu , and so on.","title":"3.5. Troubleshooting Remote Access via VS Code"},{"location":"tut1-linux-cli/","text":"Linux Command Line Basics This tutorials serves as gentle introduction to the basics of using the Linux command line on the ecelinux servers. Given you know how to log into the servers, this tutorial will cover basic Linux command line usage. In the following tutorial, we will cover Git . 1. Starting a Remote Shell We will be using the ecelinux servers for all of the programming assignments. The ecelinux servers all run the Red Hat Enterprise Linux operating system.Linux is the operating system of choice for both cloud and IoT systems, so becoming familiar with Linux will pay dividends beyond just this course. We encourage you to use PowerShell on Windows and Terminal on MacOS to log into the ecelinux servers. You can also use VS Code to log into the ecelinux servers. You can learn more about the various remote access options in this tutorial: ECELinux Access 1.1. Logging into ecelinux Servers To start PowerShell on Windows, click the Start menu then choose Windows PowerShell > Windows PowerShell , or click the Start menu, type PowerShell , and choose Windows PowerShell . Follow the equivalent steps for MacOS. Once you've opened your terminal app, the instructions are the same. Type in the following command at the prompt to log into the ecelinux servers: $ ssh <netid>@ecelinux.ece.cornell.edu Replace <netid> with your Cornell NetID in the command above. You should not enter the $ character. That is just the shell prompt. Executing the command will ask you for your Cornell NetID password. Then, you should be connected to the ecelinux servers. The very first time you log into the ecelinux servers you may see a warning like this: The authenticity of host \u2019ecelinux.ece.cornell.edu (128.253.51.206)\u2019 can\u2019t be established. ECDSA key fingerprint is SHA256:smwMnf9dyhs5zW5I279C5oJBrTFc5FLghIJMfBR1cxI. Are you sure you want to continue connecting (yes/no)? This is fine and will only occur the first time you log in. 2. Linux Command Line The command line is one of the core ways to use your computer. It is a text-based console where you can enter commands to interact with the operating system. 2.1 Hello World We will begin with the ubiquitous \"Hello World!\" example. To display the message \"Hello, World\" in our terminal, we will use the echo command. The echo command simply \"echoes\" its input to the console. $ echo \"Hello World!\" The string we provide to the echo command is called a command line argument . We use command line arguments to tell commands what they should operate on. 2.2. Man(ual) Pages You can learn more about any Linux command by using the man command. This resource is often call just \"the man pages.\" This command has its origins in the 1970s, before Google or ChatGPT. However, it is still useful today. Try using man to learn more about the echo command. $ man echo You can use the arrow keys to scroll the manual one line at a time, the space bar to scroll down one page at a time, and the 'Q' key to quit viewing the manual. 2.3. Create, View, and List Files We can use echo and a feature called redirection to create simple text files. Redirection allows use to redirect the output from a command into file. In other words, instead of displaying in our terminal the results are written to a file. The greater-than sign, > , is used to signify that we are redirecting the output. The following commands will create a new file named ece2400-sec01.txt that simply contains the text \"Computer Systems Programming\". $ echo \"Computer Systems Programming\" > ece2400-sec01.txt We can use the cat (concatenate) command to quickly display the contents of a file. $ cat ece2400-sec01.txt cat always outputs the entire file to the console, so for larger files we may resort to other options. We can use the less command to show the text one screen at a time. You can use the up/down keys to scroll the file one line at a time, the space bar to scroll down one page at a time, and the 'Q' key to quit viewing the file. $ less ece2400-sec01.txt The > redirection operator will always create a brand new file (even if the target output file already exists). You can use the >> operator to append lines to the end of a file. Let's add another line to our text file using the >> operator. $ echo \"Using C/C++\" >> ece2400-sec01.txt $ cat ece2400-sec01.txt Now we should cover how to navigate the file system. You can use the ls command to list the filenames of the files in your working directory. $ ls We can provide command line arguments to the ls command to modify the command\u2019s behavior. For example, we can use the -1 (a dash followed by the number one) command line option to list one file per line. Moreover, we can we can use the -l (a dash followed by the letter l) command line option to provide a longer listing with more information about each file. 2.4. Create, Change, and List Directories Obviously, having all files in a single location would be hard to manage. We can use directories (i.e. folders) to logically organize our files. The mechanism for organizing files and directories is called the file system. When you first login to an ecelinux machine, you will be in your home directory. This is your own private space on the server where you can work on your programming assignments. You can use the pwd command to print the directory in which you are currently working, which is known as the current 'working directory.' $ pwd /home/netid The pwd command shows the full file path to the working directory. A directory path is a list of nested directory names; it describes the \"path\" to get to a specific file or directory. The above path indicates that there is a toplevel directory named /home that contains a directory inside named netid . This is the path to your home directory. As an aside, notice that Linux uses a forward slash ( / ) to separate directories, while Windows uses a back slash ( \\ ) for the same purpose. We can use the mkdir command to make new directories. The following command will make a new directory named ece2400 within your home directory. $ mkdir ece2400 We can use the cd command to change our current working directory. The following command will change the current working directory to be the newly created ece2400 directory. $ cd ece2400 $ pwd /home/netid/ece2400 Now, use the mkdir , cd , and pwd commands to make another subdirectory. $ mkdir sec01 $ cd sec01 $ pwd /home/netid/ece2400/sec01 We would say that sec01 is a subdirectory of the ece2400 directory. We would also say that ece2400 is the parent directory of the sec01 . Use the following command to copy our text file in this child directory. $ cd /home/netid/ece2400/sec01 $ cp /home/netid/ece2400-sec01.txt /home/netid/ece2400/sec01 $ ls One short note: we can use ~/ in place of /home/netid on Linux. With that said, let's use the tree command to visualize the directory layout and where files are located: $ cd ~/ece2400 $ tree The tilde ( ~ ) is a shortcut which always refers to your home directory. Moreover, there are a few other very useful shortcuts. You can use a single dot ( . ) to refer to the current working directory, and you can use a double dot ( .. ) to refer to the parent directory of the current working directory. $ cd ~/ece2400/sec01 $ cd .. $ cd .. $ pwd 2.5. Copy, Move, and Remove Files and Directories We can use the cp command to copy files. The first argument is the name of the file you want to copy, and the second argument is the new name to give to the copy. The following commands will make two copies of the files we created in the previous section. $ cd ~/ece2400/sec01 $ cp ece2400-sec01.txt ece2400-sec01-a.txt $ cp ece2400-sec01.txt ece2400-sec01-b.txt $ ls Instead of copying we can also move a file with the mv command: $ cd ~/ece2400/sec01 $ mv ece2400-sec01.txt ece2400-sec01-c.txt $ ls Finally, we can use the rm command to remove files. $ cd ~/ece2400/sec01 $ ls $ rm ece2400-sec01-a.txt As a tip, we have installed a simple program called trash which moves files you wish to delete into a special subdirectory located at ${HOME}/tmp/trash . The following commands create a file and then deletes it using trash. $ cd ${HOME} $ echo \"This file will be deleted.\" > testing.txt $ trash testing.txt $ echo \"This file will also be deleted.\" > testing.txt $ trash testing.txt $ ls ${HOME}/tmp/trash If you look in ${HOME}/tmp/trash , you will see subdirectories organized by date. Look in the subdirectory with today's date and you should two files corresponding to the ones you deleted. We recommend using the trash command over of rm , so you can recover any accidentally deleted work. 2.6. Text Editors Students are free to use any text editor they want, although we recommend students use VS Code. VS Code is both a remote access option and a text editor. If you want to stay inside of your terminal, you can still use nano or vim . this: $ nano ece2400-sec01-b.txt When you are finished, you can go ahead and trash the sec01 directory to keep things tidy. $ trash ~/ece2400/sec01 We hope this tutorial was not too mundane, but eventually these commands will become intuitive. Over time, you will be able to use a command line more proficiently than any GUI!","title":"Linux Command Line Basics"},{"location":"tut1-linux-cli/#linux-command-line-basics","text":"This tutorials serves as gentle introduction to the basics of using the Linux command line on the ecelinux servers. Given you know how to log into the servers, this tutorial will cover basic Linux command line usage. In the following tutorial, we will cover Git .","title":"Linux Command Line Basics"},{"location":"tut1-linux-cli/#1-starting-a-remote-shell","text":"We will be using the ecelinux servers for all of the programming assignments. The ecelinux servers all run the Red Hat Enterprise Linux operating system.Linux is the operating system of choice for both cloud and IoT systems, so becoming familiar with Linux will pay dividends beyond just this course. We encourage you to use PowerShell on Windows and Terminal on MacOS to log into the ecelinux servers. You can also use VS Code to log into the ecelinux servers. You can learn more about the various remote access options in this tutorial: ECELinux Access","title":"1. Starting a Remote Shell"},{"location":"tut1-linux-cli/#11-logging-into-ecelinux-servers","text":"To start PowerShell on Windows, click the Start menu then choose Windows PowerShell > Windows PowerShell , or click the Start menu, type PowerShell , and choose Windows PowerShell . Follow the equivalent steps for MacOS. Once you've opened your terminal app, the instructions are the same. Type in the following command at the prompt to log into the ecelinux servers: $ ssh <netid>@ecelinux.ece.cornell.edu Replace <netid> with your Cornell NetID in the command above. You should not enter the $ character. That is just the shell prompt. Executing the command will ask you for your Cornell NetID password. Then, you should be connected to the ecelinux servers. The very first time you log into the ecelinux servers you may see a warning like this: The authenticity of host \u2019ecelinux.ece.cornell.edu (128.253.51.206)\u2019 can\u2019t be established. ECDSA key fingerprint is SHA256:smwMnf9dyhs5zW5I279C5oJBrTFc5FLghIJMfBR1cxI. Are you sure you want to continue connecting (yes/no)? This is fine and will only occur the first time you log in.","title":"1.1. Logging into ecelinux Servers"},{"location":"tut1-linux-cli/#2-linux-command-line","text":"The command line is one of the core ways to use your computer. It is a text-based console where you can enter commands to interact with the operating system.","title":"2. Linux Command Line"},{"location":"tut1-linux-cli/#21-hello-world","text":"We will begin with the ubiquitous \"Hello World!\" example. To display the message \"Hello, World\" in our terminal, we will use the echo command. The echo command simply \"echoes\" its input to the console. $ echo \"Hello World!\" The string we provide to the echo command is called a command line argument . We use command line arguments to tell commands what they should operate on.","title":"2.1 Hello World"},{"location":"tut1-linux-cli/#22-manual-pages","text":"You can learn more about any Linux command by using the man command. This resource is often call just \"the man pages.\" This command has its origins in the 1970s, before Google or ChatGPT. However, it is still useful today. Try using man to learn more about the echo command. $ man echo You can use the arrow keys to scroll the manual one line at a time, the space bar to scroll down one page at a time, and the 'Q' key to quit viewing the manual.","title":"2.2. Man(ual) Pages"},{"location":"tut1-linux-cli/#23-create-view-and-list-files","text":"We can use echo and a feature called redirection to create simple text files. Redirection allows use to redirect the output from a command into file. In other words, instead of displaying in our terminal the results are written to a file. The greater-than sign, > , is used to signify that we are redirecting the output. The following commands will create a new file named ece2400-sec01.txt that simply contains the text \"Computer Systems Programming\". $ echo \"Computer Systems Programming\" > ece2400-sec01.txt We can use the cat (concatenate) command to quickly display the contents of a file. $ cat ece2400-sec01.txt cat always outputs the entire file to the console, so for larger files we may resort to other options. We can use the less command to show the text one screen at a time. You can use the up/down keys to scroll the file one line at a time, the space bar to scroll down one page at a time, and the 'Q' key to quit viewing the file. $ less ece2400-sec01.txt The > redirection operator will always create a brand new file (even if the target output file already exists). You can use the >> operator to append lines to the end of a file. Let's add another line to our text file using the >> operator. $ echo \"Using C/C++\" >> ece2400-sec01.txt $ cat ece2400-sec01.txt Now we should cover how to navigate the file system. You can use the ls command to list the filenames of the files in your working directory. $ ls We can provide command line arguments to the ls command to modify the command\u2019s behavior. For example, we can use the -1 (a dash followed by the number one) command line option to list one file per line. Moreover, we can we can use the -l (a dash followed by the letter l) command line option to provide a longer listing with more information about each file.","title":"2.3. Create, View, and List Files"},{"location":"tut1-linux-cli/#24-create-change-and-list-directories","text":"Obviously, having all files in a single location would be hard to manage. We can use directories (i.e. folders) to logically organize our files. The mechanism for organizing files and directories is called the file system. When you first login to an ecelinux machine, you will be in your home directory. This is your own private space on the server where you can work on your programming assignments. You can use the pwd command to print the directory in which you are currently working, which is known as the current 'working directory.' $ pwd /home/netid The pwd command shows the full file path to the working directory. A directory path is a list of nested directory names; it describes the \"path\" to get to a specific file or directory. The above path indicates that there is a toplevel directory named /home that contains a directory inside named netid . This is the path to your home directory. As an aside, notice that Linux uses a forward slash ( / ) to separate directories, while Windows uses a back slash ( \\ ) for the same purpose. We can use the mkdir command to make new directories. The following command will make a new directory named ece2400 within your home directory. $ mkdir ece2400 We can use the cd command to change our current working directory. The following command will change the current working directory to be the newly created ece2400 directory. $ cd ece2400 $ pwd /home/netid/ece2400 Now, use the mkdir , cd , and pwd commands to make another subdirectory. $ mkdir sec01 $ cd sec01 $ pwd /home/netid/ece2400/sec01 We would say that sec01 is a subdirectory of the ece2400 directory. We would also say that ece2400 is the parent directory of the sec01 . Use the following command to copy our text file in this child directory. $ cd /home/netid/ece2400/sec01 $ cp /home/netid/ece2400-sec01.txt /home/netid/ece2400/sec01 $ ls One short note: we can use ~/ in place of /home/netid on Linux. With that said, let's use the tree command to visualize the directory layout and where files are located: $ cd ~/ece2400 $ tree The tilde ( ~ ) is a shortcut which always refers to your home directory. Moreover, there are a few other very useful shortcuts. You can use a single dot ( . ) to refer to the current working directory, and you can use a double dot ( .. ) to refer to the parent directory of the current working directory. $ cd ~/ece2400/sec01 $ cd .. $ cd .. $ pwd","title":"2.4. Create, Change, and List Directories"},{"location":"tut1-linux-cli/#25-copy-move-and-remove-files-and-directories","text":"We can use the cp command to copy files. The first argument is the name of the file you want to copy, and the second argument is the new name to give to the copy. The following commands will make two copies of the files we created in the previous section. $ cd ~/ece2400/sec01 $ cp ece2400-sec01.txt ece2400-sec01-a.txt $ cp ece2400-sec01.txt ece2400-sec01-b.txt $ ls Instead of copying we can also move a file with the mv command: $ cd ~/ece2400/sec01 $ mv ece2400-sec01.txt ece2400-sec01-c.txt $ ls Finally, we can use the rm command to remove files. $ cd ~/ece2400/sec01 $ ls $ rm ece2400-sec01-a.txt As a tip, we have installed a simple program called trash which moves files you wish to delete into a special subdirectory located at ${HOME}/tmp/trash . The following commands create a file and then deletes it using trash. $ cd ${HOME} $ echo \"This file will be deleted.\" > testing.txt $ trash testing.txt $ echo \"This file will also be deleted.\" > testing.txt $ trash testing.txt $ ls ${HOME}/tmp/trash If you look in ${HOME}/tmp/trash , you will see subdirectories organized by date. Look in the subdirectory with today's date and you should two files corresponding to the ones you deleted. We recommend using the trash command over of rm , so you can recover any accidentally deleted work.","title":"2.5. Copy, Move, and Remove Files and Directories"},{"location":"tut1-linux-cli/#26-text-editors","text":"Students are free to use any text editor they want, although we recommend students use VS Code. VS Code is both a remote access option and a text editor. If you want to stay inside of your terminal, you can still use nano or vim . this: $ nano ece2400-sec01-b.txt When you are finished, you can go ahead and trash the sec01 directory to keep things tidy. $ trash ~/ece2400/sec01 We hope this tutorial was not too mundane, but eventually these commands will become intuitive. Over time, you will be able to use a command line more proficiently than any GUI!","title":"2.6. Text Editors"},{"location":"tut2-git/","text":"Using Git Now that you know the basics of the Linux command line , you can now start to use Git to manage your code. 1. GitHub Account Setup We will be using GitHub for hosting our git repositories. You can check to see if you have a GitHub account already by going to the following link: https://github.com/githubid where githubid is your GitHub username. If the link does not work, then you do not have an GitHub account on github.com . NOTE: We are using github.com not the Cornell hosted GitHub! You will need to create one here: GitHub Signup Yo can use whichever username you want ont GitHub.com . However, be sure to use your Cornell University email address. Once your account is setup, please make sure you set your full name so we can know who you are on GitHub. Consider uploading a fun profile picture to GitHub. Go to the following page and enter your first and last name in the Name field. https://github.com/settings/profile Before you can begin using GitHub, you need to generate an SSH key pair on an ecelinux machine and upload the corresponding SSH public key to GitHub. GitHub uses these keys for authentication. GitHub has its own tutorial on how to generate a key pair on Linux: Generating a New SSH Key You can print the public key you've made to the terminal: $ cat ~/.ssh/id_ed25519 Copy the output and use the following page to add the public key to GitHub: https://github.com/settings/ssh Click on New SSH Key , and then paste the public key you displayed using cat into the key textbox. Give the key the title ecelinux . Then click Add SSH key . To test things out, try the following command: $ ssh -T git@github.com You may see a warning about the authenticity of the host. Don\u2019t worry, this is supposed to happen the first time you access GitHub using your new key. Just enter yes . The GitHub server should output some text including your GitHub ID. Verify that the GitHub ID is correct, and then you should be all set. 2. Git Version Control System In this course, we will be using Git to version control the code we write. Git will enable us to adopt an agile development methodology so you (and your group) can rapidly collaborate and iterate on the design, verification, and evaluation of the assignments. 2.1. Fork and Clone a Repo from GitHub Fork'ing a repo means making a copy of that repo for your own local use. We won't actually be forking repos for the programming assignments, but it is an easy way for you to grab some example code for the discussion section. Go to the example repo here: https://github.com/cornell-ece2400/ece2400-sec01 Click on the \"Fork\" button. Wait a few seconds and then visit the new copy of this repo in your own person GitHub workspace: https://github.com/githubid/ece2400-sec01 Replace githubid with your GitHub username. Now let's clone your new repo to the ecelinux machine. $ cd ${HOME}/ece2400 $ git clone git@github.com:githubid/ece2400-sec01 sec01 $ cd sec01 $ cat README.md where githubid is your GitHub username. 2.2. Adding and Committing Files to Local Repository Now let's add some new files to the repository. Use echo to create a file named warm-colors.txt with three warm colors: $ echo red > warm-colors.txt $ echo orange >> warm-colors.txt $ echo yellow >> warm-colors.txt Now use your favorite text editor again to create a file named cool-colors.txt with three cool colors. $ echo blue > cool-colors.txt $ echo green >> cool-colors.txt $ echo purple >> cool-colors.txt Now let's add these files to our repository. First use the git status command to check on the status of the repository. $ cd ${HOME}/ece2400/sec01 $ git status You should see that git noticed two \"untracked files\" which are in the working directory but are not currently being tracked by git. Let's \"add\" these two files to git's \"staging\" area, so it now knows it should keep track of them: $ git add warm-colors.txt $ git add cool-colors.txt $ git status The status of these two files have changed. Git reports that both of the new files are ready to be committed. Let's go ahead and commit these changes into your local repository. $ git commit -m \"add some colors\" Let's now use echo and the >> command output redirection operator to add cyan to the end of our cool-colors.txt file. We can then view our changes from the command line using cat , and use git status and then git commit to try and commit our changes. $ echo \"cyan\" >> cool-colors.txt $ cat cool-colors.txt $ git status $ git commit -m \"add cyan\" Git will report that there are no changes added to the commit. So even though Git is tracking cool-colors.txt and knows it has changed, we still must explicitly add the files we want to commit. We recommend using the git add -u command to tell Git to add any file which has changed and was previously added to the repository. $ git add -u $ git commit -m \"add cyan\" Now the changes are committed. You can use git log to see a log of the commits in your local repository. $ cd ${HOME}/ece2400/sec01 $ git log 2.3. Pushing Files to GitHub Note that nothing has happened on GitHub yet. GitHub does not know anything about these local changes. We need to explicitly \"push\" our new commits up to GitHub like this: $ git push Now go to the repository page using the GitHub web interface and verify that there are two new files. https://github.com/githubid/ece2400-sec01 2.4. Pulling Files from GitHub Let's try making a change to this repository through the GitHub web interface. https://github.com/githubid/ece2400-sec01 Click on Add file and then Create new file . Name the file languages.txt and add a list of programming languages: C C++ Python MATLAB Java Now click Commit new file . Verify that there is a new file in the repo using the GitHub web interface. Now let's \"pull\" these new changes from GitHub to your local repo on ecelinux : $ git pull $ cat languages.txt This will be the basic GitHub workflow. Students should: git clone the repo to ecelinux git add -u to add their code changes Commit their changes with a message git commit -m \"message\" Sync their changes to GitHub with git push","title":"Using Git"},{"location":"tut2-git/#using-git","text":"Now that you know the basics of the Linux command line , you can now start to use Git to manage your code.","title":"Using Git"},{"location":"tut2-git/#1-github-account-setup","text":"We will be using GitHub for hosting our git repositories. You can check to see if you have a GitHub account already by going to the following link: https://github.com/githubid where githubid is your GitHub username. If the link does not work, then you do not have an GitHub account on github.com . NOTE: We are using github.com not the Cornell hosted GitHub! You will need to create one here: GitHub Signup Yo can use whichever username you want ont GitHub.com . However, be sure to use your Cornell University email address. Once your account is setup, please make sure you set your full name so we can know who you are on GitHub. Consider uploading a fun profile picture to GitHub. Go to the following page and enter your first and last name in the Name field. https://github.com/settings/profile Before you can begin using GitHub, you need to generate an SSH key pair on an ecelinux machine and upload the corresponding SSH public key to GitHub. GitHub uses these keys for authentication. GitHub has its own tutorial on how to generate a key pair on Linux: Generating a New SSH Key You can print the public key you've made to the terminal: $ cat ~/.ssh/id_ed25519 Copy the output and use the following page to add the public key to GitHub: https://github.com/settings/ssh Click on New SSH Key , and then paste the public key you displayed using cat into the key textbox. Give the key the title ecelinux . Then click Add SSH key . To test things out, try the following command: $ ssh -T git@github.com You may see a warning about the authenticity of the host. Don\u2019t worry, this is supposed to happen the first time you access GitHub using your new key. Just enter yes . The GitHub server should output some text including your GitHub ID. Verify that the GitHub ID is correct, and then you should be all set.","title":"1. GitHub Account Setup"},{"location":"tut2-git/#2-git-version-control-system","text":"In this course, we will be using Git to version control the code we write. Git will enable us to adopt an agile development methodology so you (and your group) can rapidly collaborate and iterate on the design, verification, and evaluation of the assignments.","title":"2. Git Version Control System"},{"location":"tut2-git/#21-fork-and-clone-a-repo-from-github","text":"Fork'ing a repo means making a copy of that repo for your own local use. We won't actually be forking repos for the programming assignments, but it is an easy way for you to grab some example code for the discussion section. Go to the example repo here: https://github.com/cornell-ece2400/ece2400-sec01 Click on the \"Fork\" button. Wait a few seconds and then visit the new copy of this repo in your own person GitHub workspace: https://github.com/githubid/ece2400-sec01 Replace githubid with your GitHub username. Now let's clone your new repo to the ecelinux machine. $ cd ${HOME}/ece2400 $ git clone git@github.com:githubid/ece2400-sec01 sec01 $ cd sec01 $ cat README.md where githubid is your GitHub username.","title":"2.1. Fork and Clone a Repo from GitHub"},{"location":"tut2-git/#22-adding-and-committing-files-to-local-repository","text":"Now let's add some new files to the repository. Use echo to create a file named warm-colors.txt with three warm colors: $ echo red > warm-colors.txt $ echo orange >> warm-colors.txt $ echo yellow >> warm-colors.txt Now use your favorite text editor again to create a file named cool-colors.txt with three cool colors. $ echo blue > cool-colors.txt $ echo green >> cool-colors.txt $ echo purple >> cool-colors.txt Now let's add these files to our repository. First use the git status command to check on the status of the repository. $ cd ${HOME}/ece2400/sec01 $ git status You should see that git noticed two \"untracked files\" which are in the working directory but are not currently being tracked by git. Let's \"add\" these two files to git's \"staging\" area, so it now knows it should keep track of them: $ git add warm-colors.txt $ git add cool-colors.txt $ git status The status of these two files have changed. Git reports that both of the new files are ready to be committed. Let's go ahead and commit these changes into your local repository. $ git commit -m \"add some colors\" Let's now use echo and the >> command output redirection operator to add cyan to the end of our cool-colors.txt file. We can then view our changes from the command line using cat , and use git status and then git commit to try and commit our changes. $ echo \"cyan\" >> cool-colors.txt $ cat cool-colors.txt $ git status $ git commit -m \"add cyan\" Git will report that there are no changes added to the commit. So even though Git is tracking cool-colors.txt and knows it has changed, we still must explicitly add the files we want to commit. We recommend using the git add -u command to tell Git to add any file which has changed and was previously added to the repository. $ git add -u $ git commit -m \"add cyan\" Now the changes are committed. You can use git log to see a log of the commits in your local repository. $ cd ${HOME}/ece2400/sec01 $ git log","title":"2.2. Adding and Committing Files to Local Repository"},{"location":"tut2-git/#23-pushing-files-to-github","text":"Note that nothing has happened on GitHub yet. GitHub does not know anything about these local changes. We need to explicitly \"push\" our new commits up to GitHub like this: $ git push Now go to the repository page using the GitHub web interface and verify that there are two new files. https://github.com/githubid/ece2400-sec01","title":"2.3. Pushing Files to GitHub"},{"location":"tut2-git/#24-pulling-files-from-github","text":"Let's try making a change to this repository through the GitHub web interface. https://github.com/githubid/ece2400-sec01 Click on Add file and then Create new file . Name the file languages.txt and add a list of programming languages: C C++ Python MATLAB Java Now click Commit new file . Verify that there is a new file in the repo using the GitHub web interface. Now let's \"pull\" these new changes from GitHub to your local repo on ecelinux : $ git pull $ cat languages.txt This will be the basic GitHub workflow. Students should: git clone the repo to ecelinux git add -u to add their code changes Commit their changes with a message git commit -m \"message\" Sync their changes to GitHub with git push","title":"2.4. Pulling Files from GitHub"}]}